<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON PRECISION V18 - OFFLINE MASTER</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;500&display=swap');
        
        :root {
            --neon-cyan: #00f3ff;
            --neon-emerald: #00ff9d;
            --neon-crimson: #ff0055;
            --neon-purple: #9d00ff;
            --bg-dark: #0a0a0f;
        }
        
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: var(--bg-dark);
            color: white;
            overflow-x: hidden;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 243, 255, 0.05) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(157, 0, 255, 0.05) 0%, transparent 20%);
        }
        
        .cyber-card {
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-radius: 12px;
            box-shadow: 
                0 0 20px rgba(0, 243, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .cyber-card-emerald {
            border: 1px solid rgba(0, 255, 157, 0.2);
            box-shadow: 
                0 0 20px rgba(0, 255, 157, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .cyber-card-crimson {
            border: 1px solid rgba(255, 0, 85, 0.2);
            box-shadow: 
                0 0 20px rgba(255, 0, 85, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .neon-text-cyan {
            color: var(--neon-cyan);
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.7);
        }
        
        .neon-text-emerald {
            color: var(--neon-emerald);
            text-shadow: 0 0 10px rgba(0, 255, 157, 0.7);
        }
        
        .neon-text-crimson {
            color: var(--neon-crimson);
            text-shadow: 0 0 10px rgba(255, 0, 85, 0.7);
        }
        
        .neon-border-cyan {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.5);
        }
        
        .neon-border-emerald {
            border-color: var(--neon-emerald);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.5);
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 243, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 243, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 243, 255, 0); }
        }
        
        .glow {
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { box-shadow: 0 0 10px rgba(0, 243, 255, 0.5), 0 0 20px rgba(0, 243, 255, 0.3); }
            to { box-shadow: 0 0 15px rgba(0, 243, 255, 0.8), 0 0 25px rgba(0, 243, 255, 0.5); }
        }
        
        .game-btn {
            transition: all 0.2s ease;
            font-weight: 600;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 1.1rem;
        }
        
        .game-btn:active {
            transform: scale(0.95);
        }
        
        .number-chip {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .number-chip:active {
            transform: scale(0.9);
        }
        
        .phase-indicator {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        
        .history-chip {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .tab-btn {
            padding: 12px 24px;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active {
            position: relative;
            z-index: 10;
        }
        
        /* Scrollbar personalizada */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(30, 30, 40, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--neon-cyan);
            border-radius: 4px;
        }
        
        /* Estilos para móviles */
        @media (max-width: 640px) {
            .game-btn {
                padding: 10px 16px;
                font-size: 1rem;
            }
            
            .number-chip {
                width: 38px;
                height: 38px;
                font-size: 0.9rem;
            }
            
            .history-chip {
                width: 30px;
                height: 30px;
                font-size: 0.8rem;
            }
            
            .phase-indicator {
                font-size: 0.75rem;
                padding: 4px 10px;
            }
        }
        
        /* Animación de entrada de número */
        @keyframes numberPop {
            0% { transform: scale(0.8); opacity: 0; }
            70% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .number-pop {
            animation: numberPop 0.3s ease-out;
        }
        
        /* Estilo para números recién agregados */
        .recent-number {
            animation: pulse 1s 2;
        }
    </style>
</head>
<body class="min-h-screen p-3 md:p-5">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-6 md:mb-8">
            <h1 class="text-3xl md:text-4xl lg:text-5xl font-bold font-['Orbitron'] neon-text-cyan mb-2">
                NEON PRECISION V18
            </h1>
            <p class="text-lg md:text-xl text-gray-300 font-['Orbitron']">OFFLINE MASTER - MATEMÁTICA CORREGIDA</p>
            <div class="flex flex-wrap justify-center items-center gap-4 mt-4">
                <div class="phase-indicator bg-gray-800 text-gray-300">SISTEMA LOCAL • 0ms LATENCIA</div>
                <div class="phase-indicator bg-gray-800 text-gray-300">ALGORITMOS DE PROBABILIDAD</div>
            </div>
        </header>

        <!-- Tabs de juegos -->
        <div class="flex border-b border-gray-800 mb-6">
            <button id="tab-roulette" class="tab-btn active bg-gray-900 text-white neon-border-cyan">
                <div class="flex items-center gap-2">
                    <i data-lucide="circle"></i>
                    <span>RULETA EUROPEA</span>
                </div>
            </button>
            <button id="tab-baccarat" class="tab-btn bg-gray-900 text-gray-400">
                <div class="flex items-center gap-2">
                    <i data-lucide="diamond"></i>
                    <span>BACCARAT</span>
                </div>
            </button>
        </div>

        <!-- Contenedor principal -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-5 md:gap-6">
            <!-- Panel izquierdo: Juego -->
            <div class="lg:col-span-2">
                <!-- Panel de Ruleta -->
                <div id="roulette-panel" class="game-panel">
                    <!-- Fase actual -->
                    <div class="cyber-card p-4 mb-5">
                        <div class="flex flex-wrap items-center justify-between gap-3">
                            <div>
                                <h2 class="text-xl font-bold flex items-center gap-2">
                                    <i data-lucide="circle" class="neon-text-cyan"></i>
                                    <span>RULETA EUROPEA</span>
                                </h2>
                                <div id="roulette-phase" class="phase-indicator bg-blue-900/30 text-blue-300 mt-1">FASE 1: RECOLECCIÓN (0/37)</div>
                            </div>
                            <div class="text-right">
                                <div class="text-sm text-gray-400">Capital Actual</div>
                                <div class="text-2xl font-bold neon-text-cyan">$<span id="roulette-balance">50000</span></div>
                            </div>
                        </div>
                    </div>

                    <!-- Controles de capital MEJORADOS -->
                    <div class="cyber-card p-4 mb-5">
                        <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                            <i data-lucide="trending-up"></i>
                            <span>GESTIÓN DE CAPITAL</span>
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Capital</label>
                                <input type="number" id="roulette-capital" value="50000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Meta</label>
                                <input type="number" id="roulette-target" value="50000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Stop Loss</label>
                                <input type="number" id="roulette-stop-loss" value="30000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Unidad Base</label>
                                <div class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                                    $<span id="roulette-unit">500</span> (1% del capital)
                                </div>
                            </div>
                        </div>
                        <div class="mt-4 flex flex-wrap gap-3">
                            <button id="roulette-reset" class="game-btn bg-gray-800 hover:bg-gray-700 text-white">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="refresh-ccw"></i>
                                    <span>Cambio de Crupier</span>
                                </div>
                            </button>
                            <button id="roulette-clear" class="game-btn bg-red-900/30 hover:bg-red-800/40 text-red-300">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="trash-2"></i>
                                    <span>Finalizar Sesión</span>
                                </div>
                            </button>
                        </div>
                    </div>

                    <!-- Tablero de ruleta CORREGIDO (solo números 0-36) -->
                    <div class="cyber-card p-4 md:p-5 mb-5">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <i data-lucide="grid-3x3"></i>
                            <span>TABLERO DE NÚMEROS (0-36)</span>
                        </h3>
                        <div class="grid grid-cols-4 sm:grid-cols-7 md:grid-cols-9 lg:grid-cols-13 gap-2 mb-4" id="roulette-numbers-grid">
                            <!-- Los números se generarán dinámicamente con JavaScript -->
                        </div>
                        <div class="grid grid-cols-3 gap-3 mb-4">
                            <button id="roulette-dozen-1" class="game-btn bg-gray-800 hover:bg-gray-700 text-white">1-12</button>
                            <button id="roulette-dozen-2" class="game-btn bg-gray-800 hover:bg-gray-700 text-white">13-24</button>
                            <button id="roulette-dozen-3" class="game-btn bg-gray-800 hover:bg-gray-700 text-white">25-36</button>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <button id="roulette-red" class="game-btn bg-red-900/30 hover:bg-red-800/40 text-red-300">ROJO</button>
                            <button id="roulette-black" class="game-btn bg-gray-900 hover:bg-gray-800 text-white">NEGRO</button>
                        </div>
                        <div class="mt-4 text-center">
                            <div class="text-sm text-gray-400 mb-2">AYUDA RÁPIDA</div>
                            <div class="text-xs text-gray-500">Toca cualquier número (0-36) para registrar el resultado. El sistema analizará automáticamente los patrones.</div>
                        </div>
                    </div>

                    <!-- Panel de predicción MEJORADO -->
                    <div id="roulette-prediction" class="cyber-card cyber-card-emerald p-4 md:p-5 mb-5">
                        <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                            <i data-lucide="zap"></i>
                            <span>PANEL DE PREDICCIÓN - ALGORITMO MATEMÁTICO</span>
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">PREDICCIÓN</div>
                                <div id="roulette-prediction-value" class="text-2xl font-bold neon-text-emerald">ESPERAR</div>
                            </div>
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">CONFIANZA</div>
                                <div id="roulette-confidence" class="text-2xl font-bold neon-text-emerald">0%</div>
                            </div>
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">APUESTA SUGERIDA</div>
                                <div id="roulette-bet" class="text-2xl font-bold neon-text-emerald">$0</div>
                            </div>
                        </div>
                        <div class="text-center">
                            <div id="roulette-prediction-details" class="text-gray-300 text-sm">
                                <div>Recolectando datos... (0/37 números registrados)</div>
                                <div class="mt-1 text-xs text-gray-500">Algoritmo: Ley del Tercio + Análisis de Desviación + Zonas Calientes</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Panel de Baccarat -->
                <div id="baccarat-panel" class="game-panel hidden">
                    <!-- Fase actual -->
                    <div class="cyber-card p-4 mb-5">
                        <div class="flex flex-wrap items-center justify-between gap-3">
                            <div>
                                <h2 class="text-xl font-bold flex items-center gap-2">
                                    <i data-lucide="diamond" class="neon-text-purple"></i>
                                    <span>BACCARAT</span>
                                </h2>
                                <div id="baccarat-phase" class="phase-indicator bg-purple-900/30 text-purple-300 mt-1">FASE 1: RECOLECCIÓN (0/15)</div>
                            </div>
                            <div class="text-right">
                                <div class="text-sm text-gray-400">Capital Actual</div>
                                <div class="text-2xl font-bold neon-text-purple">$<span id="baccarat-balance">50000</span></div>
                            </div>
                        </div>
                    </div>

                    <!-- Controles de capital MEJORADOS -->
                    <div class="cyber-card p-4 mb-5">
                        <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                            <i data-lucide="trending-up"></i>
                            <span>GESTIÓN DE CAPITAL</span>
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Capital</label>
                                <input type="number" id="baccarat-capital" value="50000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Meta</label>
                                <input type="number" id="baccarat-target" value="50000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Stop Loss</label>
                                <input type="number" id="baccarat-stop-loss" value="30000" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                            </div>
                            <div>
                                <label class="block text-sm text-gray-400 mb-1">Unidad Base</label>
                                <div class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                                    $<span id="baccarat-unit">500</span> (1% del capital)
                                </div>
                            </div>
                        </div>
                        <div class="mt-4 flex flex-wrap gap-3">
                            <button id="baccarat-reset" class="game-btn bg-gray-800 hover:bg-gray-700 text-white">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="refresh-ccw"></i>
                                    <span>Cambio de Shoe</span>
                                </div>
                            </button>
                            <button id="baccarat-clear" class="game-btn bg-red-900/30 hover:bg-red-800/40 text-red-300">
                                <div class="flex items-center gap-2">
                                    <i data-lucide="trash-2"></i>
                                    <span>Finalizar Sesión</span>
                                </div>
                            </button>
                        </div>
                    </div>

                    <!-- Tablero de Baccarat -->
                    <div class="cyber-card p-4 md:p-5 mb-5">
                        <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                            <i data-lucide="table"></i>
                            <span>RESULTADOS BACCARAT - ODDS REALES</span>
                        </h3>
                        <div class="grid grid-cols-3 gap-4 mb-6">
                            <button id="baccarat-banker" class="game-btn bg-blue-900/30 hover:bg-blue-800/40 text-blue-300 py-4">
                                <div class="flex flex-col items-center">
                                    <i data-lucide="shield" class="w-8 h-8 mb-2"></i>
                                    <span>BANKER (0.95:1)</span>
                                    <div class="text-xs mt-1 text-gray-400">Comisión 5%</div>
                                </div>
                            </button>
                            <button id="baccarat-player" class="game-btn bg-red-900/30 hover:bg-red-800/40 text-red-300 py-4">
                                <div class="flex flex-col items-center">
                                    <i data-lucide="user" class="w-8 h-8 mb-2"></i>
                                    <span>PLAYER (1:1)</span>
                                    <div class="text-xs mt-1 text-gray-400">Sin comisión</div>
                                </div>
                            </button>
                            <button id="baccarat-tie" class="game-btn bg-gray-800 hover:bg-gray-700 text-white py-4">
                                <div class="flex flex-col items-center">
                                    <i data-lucide="equal" class="w-8 h-8 mb-2"></i>
                                    <span>EMPATE (8:1)</span>
                                    <div class="text-xs mt-1 text-gray-400">Apuesta arriesgada</div>
                                </div>
                            </button>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">PATRÓN DETECTADO</div>
                            <div id="baccarat-pattern" class="text-lg font-bold neon-text-emerald">Recolectando datos...</div>
                        </div>
                    </div>

                    <!-- Panel de predicción MEJORADO -->
                    <div id="baccarat-prediction" class="cyber-card cyber-card-emerald p-4 md:p-5">
                        <h3 class="text-lg font-bold mb-3 flex items-center gap-2">
                            <i data-lucide="zap"></i>
                            <span>PANEL DE PREDICCIÓN - ALGORITMO MATEMÁTICO</span>
                        </h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">PREDICCIÓN</div>
                                <div id="baccarat-prediction-value" class="text-2xl font-bold neon-text-emerald">ESPERAR</div>
                            </div>
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">CONFIANZA</div>
                                <div id="baccarat-confidence" class="text-2xl font-bold neon-text-emerald">0%</div>
                            </div>
                            <div class="text-center p-4 bg-gray-900/50 rounded-lg">
                                <div class="text-sm text-gray-400 mb-1">APUESTA SUGERIDA</div>
                                <div id="baccarat-bet" class="text-2xl font-bold neon-text-emerald">$0</div>
                            </div>
                        </div>
                        <div class="text-center">
                            <div id="baccarat-prediction-details" class="text-gray-300 text-sm">
                                <div>Recolectando datos... (0/15 resultados registrados)</div>
                                <div class="mt-1 text-xs text-gray-500">Algoritmo: ZigZag + Big Road + Análisis de Rachas + Probabilidad Bayesiana</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Panel derecho: Historial y estadísticas -->
            <div class="lg:col-span-1">
                <!-- Historial de Ruleta MEJORADO -->
                <div id="roulette-history-panel" class="cyber-card p-4 md:p-5 h-full">
                    <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <i data-lucide="history"></i>
                        <span>HISTORIAL RULETA</span>
                    </h3>
                    <div class="mb-6">
                        <div class="text-sm text-gray-400 mb-2">ESTADÍSTICAS MATEMÁTICAS</div>
                        <div class="grid grid-cols-2 gap-3 mb-4">
                            <div class="bg-gray-900/50 p-3 rounded-lg">
                                <div class="text-sm text-gray-400">Números Registrados</div>
                                <div id="roulette-stats-count" class="text-xl font-bold neon-text-cyan">0</div>
                            </div>
                            <div class="bg-gray-900/50 p-3 rounded-lg">
                                <div class="text-sm text-gray-400">Precisión Fantasma</div>
                                <div id="roulette-ghost-accuracy" class="text-xl font-bold neon-text-cyan">0%</div>
                            </div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">ANÁLISIS DE DOCENAS (LEY DEL TERCIO)</div>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span>Docena 1 (1-12):</span>
                                    <span id="roulette-dozen-1-count" class="font-bold">0 <span class="text-xs text-gray-500">(33% esperado)</span></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Docena 2 (13-24):</span>
                                    <span id="roulette-dozen-2-count" class="font-bold">0 <span class="text-xs text-gray-500">(33% esperado)</span></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Docena 3 (25-36):</span>
                                    <span id="roulette-dozen-3-count" class="font-bold">0 <span class="text-xs text-gray-500">(33% esperado)</span></span>
                                </div>
                            </div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">DESVIACIÓN ESTÁNDAR</div>
                            <div id="roulette-deviation" class="text-lg font-bold neon-text-cyan">0% (Equilibrio perfecto)</div>
                        </div>
                    </div>
                    <div>
                        <div class="text-sm text-gray-400 mb-2">ÚLTIMOS 20 NÚMEROS</div>
                        <div id="roulette-history" class="flex flex-wrap gap-2 mb-4 max-h-60 overflow-y-auto p-2">
                            <!-- Historial se generará aquí -->
                        </div>
                        <div class="text-center">
                            <button id="roulette-undo" class="game-btn bg-gray-800 hover:bg-gray-700 text-white text-sm">
                                <div class="flex items-center gap-1">
                                    <i data-lucide="undo" class="w-4 h-4"></i>
                                    <span>Deshacer Último</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Historial de Baccarat -->
                <div id="baccarat-history-panel" class="cyber-card p-4 md:p-5 h-full hidden">
                    <h3 class="text-lg font-bold mb-4 flex items-center gap-2">
                        <i data-lucide="history"></i>
                        <span>HISTORIAL BACCARAT</span>
                    </h3>
                    <div class="mb-6">
                        <div class="text-sm text-gray-400 mb-2">ESTADÍSTICAS MATEMÁTICAS</div>
                        <div class="grid grid-cols-2 gap-3 mb-4">
                            <div class="bg-gray-900/50 p-3 rounded-lg">
                                <div class="text-sm text-gray-400">Resultados Registrados</div>
                                <div id="baccarat-stats-count" class="text-xl font-bold neon-text-purple">0</div>
                            </div>
                            <div class="bg-gray-900/50 p-3 rounded-lg">
                                <div class="text-sm text-gray-400">Precisión Fantasma</div>
                                <div id="baccarat-ghost-accuracy" class="text-xl font-bold neon-text-purple">0%</div>
                            </div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">DISTRIBUCIÓN PROBABILÍSTICA</div>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span>Banker:</span>
                                    <span id="baccarat-banker-count" class="font-bold">0 <span class="text-xs text-gray-500">(45.8% esperado)</span></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Player:</span>
                                    <span id="baccarat-player-count" class="font-bold">0 <span class="text-xs text-gray-500">(44.6% esperado)</span></span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Empate:</span>
                                    <span id="baccarat-tie-count" class="font-bold">0 <span class="text-xs text-gray-500">(9.6% esperado)</span></span>
                                </div>
                            </div>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-gray-400 mb-2">RACHA ACTUAL</div>
                            <div id="baccarat-streak" class="text-lg font-bold neon-text-purple">Sin racha detectada</div>
                        </div>
                    </div>
                    <div>
                        <div class="text-sm text-gray-400 mb-2">ÚLTIMOS 20 RESULTADOS</div>
                        <div id="baccarat-history" class="flex flex-wrap gap-2 mb-4 max-h-60 overflow-y-auto p-2">
                            <!-- Historial se generará aquí -->
                        </div>
                        <div class="text-center">
                            <button id="baccarat-undo" class="game-btn bg-gray-800 hover:bg-gray-700 text-white text-sm">
                                <div class="flex items-center gap-1">
                                    <i data-lucide="undo" class="w-4 h-4"></i>
                                    <span>Deshacer Último</span>
                                </div>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="mt-8 text-center text-gray-500 text-sm">
            <div class="cyber-card p-4">
                <p>NEON PRECISION V18 - OFFLINE MASTER • Sistema de probabilidad local • TODOS LOS CÁLCULOS MATEMÁTICOS IMPLEMENTADOS</p>
                <p class="mt-2">Los juegos de azar son para entretenimiento. Juega responsablemente. Las matemáticas no garantizan ganancias.</p>
            </div>
        </footer>
    </div>

    <script>
        // Inicializar Lucide icons
        lucide.createIcons();

        // Variables globales
        const APP_VERSION = 'v1.8';
        const STORAGE_KEY = 'neon_precision_v18_corregido';
        
        // Estados del sistema
        const PHASES = {
            COLLECTION: 1,
            GHOST: 2,
            ACTIVE: 3,
            PROTECTION: 4
        };

        // Configuración inicial para Ruleta - CORREGIDA
        let rouletteState = {
            game: 'roulette',
            phase: PHASES.COLLECTION,
            balance: 50000,
            target: 50000,
            stopLoss: 30000,
            unit: 500,
            history: [],
            ghostHistory: [],
            ghostPredictions: [],
            consecutiveLosses: 0,
            betSequence: 0,
            lastBet: 0,
            dozenCounts: [0, 0, 0],
            colorCounts: { red: 0, black: 0, green: 0 },
            numberCounts: new Array(37).fill(0), // 0-36
            hotNumbers: [],
            lastPrediction: null,
            calibrationComplete: false,
            dataCollected: 0,
            requiredForCollection: 37,
            requiredForGhost: 10,
            ghostAccuracy: 0,
            deviation: 0,
            lastNumbers: []
        };

        // Configuración inicial para Baccarat - CORREGIDA
        let baccaratState = {
            game: 'baccarat',
            phase: PHASES.COLLECTION,
            balance: 50000,
            target: 50000,
            stopLoss: 30000,
            unit: 500,
            history: [],
            ghostHistory: [],
            ghostPredictions: [],
            consecutiveLosses: 0,
            betSequence: 0,
            lastBet: 0,
            pattern: 'Ninguno',
            distribution: { banker: 0, player: 0, tie: 0 },
            streaks: { banker: 0, player: 0, tie: 0 },
            currentStreak: { type: null, count: 0 },
            lastPrediction: null,
            calibrationComplete: false,
            dataCollected: 0,
            requiredForCollection: 15,
            requiredForGhost: 10,
            ghostAccuracy: 0,
            lastResults: []
        };

        // Estado actual del juego activo
        let currentGame = 'roulette';
        
        // Cargar estado guardado
        function loadState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    if (parsed.roulette) {
                        rouletteState = { ...rouletteState, ...parsed.roulette };
                    }
                    if (parsed.baccarat) {
                        baccaratState = { ...baccaratState, ...parsed.baccarat };
                    }
                    if (parsed.currentGame) {
                        currentGame = parsed.currentGame;
                    }
                } catch (e) {
                    console.error('Error cargando estado:', e);
                }
            }
        }

        // Guardar estado
        function saveState() {
            const state = {
                roulette: rouletteState,
                baccarat: baccaratState,
                currentGame: currentGame
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        // Inicializar la aplicación
        function initApp() {
            loadState();
            setupEventListeners();
            generateRouletteNumbers();
            updateUI();
        }

        // Configurar listeners de eventos - MEJORADO
        function setupEventListeners() {
            // Tabs de juego
            document.getElementById('tab-roulette').addEventListener('click', () => switchGame('roulette'));
            document.getElementById('tab-baccarat').addEventListener('click', () => switchGame('baccarat'));
            
            // Botones de ruleta (se asignan dinámicamente en generateRouletteNumbers)
            
            // Botones de docenas
            document.getElementById('roulette-dozen-1').addEventListener('click', () => addRouletteDozen(1));
            document.getElementById('roulette-dozen-2').addEventListener('click', () => addRouletteDozen(2));
            document.getElementById('roulette-dozen-3').addEventListener('click', () => addRouletteDozen(3));
            document.getElementById('roulette-red').addEventListener('click', () => addRouletteColor('red'));
            document.getElementById('roulette-black').addEventListener('click', () => addRouletteColor('black'));
            
            // Botones de baccarat
            document.getElementById('baccarat-banker').addEventListener('click', () => addBaccaratResult('banker'));
            document.getElementById('baccarat-player').addEventListener('click', () => addBaccaratResult('player'));
            document.getElementById('baccarat-tie').addEventListener('click', () => addBaccaratResult('tie'));
            
            // Botones de control
            document.getElementById('roulette-reset').addEventListener('click', () => resetGame('roulette'));
            document.getElementById('roulette-clear').addEventListener('click', () => clearSession('roulette'));
            document.getElementById('roulette-undo').addEventListener('click', () => undoLast('roulette'));
            
            document.getElementById('baccarat-reset').addEventListener('click', () => resetGame('baccarat'));
            document.getElementById('baccarat-clear').addEventListener('click', () => clearSession('baccarat'));
            document.getElementById('baccarat-undo').addEventListener('click', () => undoLast('baccarat'));
            
            // Inputs de gestión de capital - CORREGIDOS
            document.getElementById('roulette-capital').addEventListener('change', (e) => {
                const newBalance = parseInt(e.target.value) || 50000;
                rouletteState.balance = newBalance;
                rouletteState.unit = Math.max(1, Math.floor(newBalance * 0.01));
                saveState();
                updateUI();
            });
            
            document.getElementById('roulette-target').addEventListener('change', (e) => {
                rouletteState.target = parseInt(e.target.value) || 50000;
                saveState();
                updateUI();
            });
            
            document.getElementById('roulette-stop-loss').addEventListener('change', (e) => {
                rouletteState.stopLoss = parseInt(e.target.value) || 30000;
                saveState();
                updateUI();
            });
            
            document.getElementById('baccarat-capital').addEventListener('change', (e) => {
                const newBalance = parseInt(e.target.value) || 50000;
                baccaratState.balance = newBalance;
                baccaratState.unit = Math.max(1, Math.floor(newBalance * 0.01));
                saveState();
                updateUI();
            });
            
            document.getElementById('baccarat-target').addEventListener('change', (e) => {
                baccaratState.target = parseInt(e.target.value) || 50000;
                saveState();
                updateUI();
            });
            
            document.getElementById('baccarat-stop-loss').addEventListener('change', (e) => {
                baccaratState.stopLoss = parseInt(e.target.value) || 30000;
                saveState();
                updateUI();
            });
        }

        // Generar números de ruleta (0-36) CORRECTO
        function generateRouletteNumbers() {
            const container = document.getElementById('roulette-numbers-grid');
            if (!container) return;
            
            let html = '';
            
            // Número 0 (verde)
            html += `<div class="number-chip bg-green-900 text-white recent-number" data-number="0" title="Cero (Verde)">0</div>`;
            
            // Números 1-36
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            
            for (let i = 1; i <= 36; i++) {
                const isRed = redNumbers.includes(i);
                const colorClass = isRed ? 'bg-red-900/30 text-red-300' : 'bg-gray-900 text-white';
                html += `<div class="number-chip ${colorClass}" data-number="${i}" title="Número ${i}">${i}</div>`;
            }
            
            container.innerHTML = html;
            
            // Asignar eventos a los números
            for (let i = 0; i <= 36; i++) {
                const btn = container.querySelector(`.number-chip[data-number="${i}"]`);
                if (btn) {
                    btn.addEventListener('click', () => addRouletteNumber(i));
                }
            }
        }

        // Cambiar entre juegos
        function switchGame(game) {
            currentGame = game;
            
            // Actualizar tabs
            document.getElementById('tab-roulette').classList.toggle('active', game === 'roulette');
            document.getElementById('tab-roulette').classList.toggle('neon-border-cyan', game === 'roulette');
            document.getElementById('tab-roulette').classList.toggle('text-white', game === 'roulette');
            document.getElementById('tab-roulette').classList.toggle('text-gray-400', game !== 'roulette');
            
            document.getElementById('tab-baccarat').classList.toggle('active', game === 'baccarat');
            document.getElementById('tab-baccarat').classList.toggle('neon-border-cyan', game === 'baccarat');
            document.getElementById('tab-baccarat').classList.toggle('text-white', game === 'baccarat');
            document.getElementById('tab-baccarat').classList.toggle('text-gray-400', game !== 'baccarat');
            
            // Mostrar/ocultar paneles
            document.getElementById('roulette-panel').classList.toggle('hidden', game !== 'roulette');
            document.getElementById('baccarat-panel').classList.toggle('hidden', game !== 'baccarat');
            document.getElementById('roulette-history-panel').classList.toggle('hidden', game !== 'roulette');
            document.getElementById('baccarat-history-panel').classList.toggle('hidden', game !== 'baccarat');
            
            saveState();
            updateUI();
        }

        // Añadir número a ruleta - CORREGIDO (solo 0-36)
        function addRouletteNumber(number) {
            if (number < 0 || number > 36) {
                showNotification('Error: Número inválido. Solo se permiten números del 0 al 36.');
                return;
            }
            
            const state = rouletteState;
            
            // Animación de click
            const btn = document.querySelector(`.number-chip[data-number="${number}"]`);
            if (btn) {
                btn.classList.add('number-pop');
                setTimeout(() => btn.classList.remove('number-pop'), 300);
            }
            
            // Determinar color
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            let color = 'green';
            if (number > 0) {
                color = redNumbers.includes(number) ? 'red' : 'black';
            }
            
            // Determinar docena (0 no tiene docena)
            let dozen = 0;
            if (number > 0) {
                dozen = Math.ceil(number / 12);
            }
            
            // Actualizar estadísticas
            state.colorCounts[color]++;
            if (dozen > 0) {
                state.dozenCounts[dozen-1]++;
            }
            state.numberCounts[number]++;
            
            // Añadir al historial
            const result = {
                number,
                color,
                dozen,
                timestamp: Date.now()
            };
            
            state.history.unshift(result);
            state.lastNumbers.unshift(number);
            if (state.lastNumbers.length > 20) {
                state.lastNumbers.pop();
            }
            
            state.dataCollected++;
            
            // Calcular desviación
            calculateRouletteDeviation();
            
            // Manejo de fases
            handleRoulettePhases();
            
            saveState();
            updateUI();
            
            // Mostrar confirmación
            const colorNames = { red: 'ROJO', black: 'NEGRO', green: 'VERDE' };
            showNotification(`Ruleta: Número ${number} (${colorNames[color]}) registrado. Total: ${state.dataCollected}/37`);
        }

        // Calcular desviación de la ruleta
        function calculateRouletteDeviation() {
            const state = rouletteState;
            if (state.dataCollected === 0) {
                state.deviation = 0;
                return;
            }
            
            // Calcular desviación estándar de las docenas
            const expectedDozen = state.dataCollected / 3;
            const variances = state.dozenCounts.map(count => Math.pow(count - expectedDozen, 2));
            const variance = variances.reduce((a, b) => a + b, 0) / 3;
            const stdDev = Math.sqrt(variance);
            
            // Calcular desviación como porcentaje
            state.deviation = Math.round((stdDev / expectedDozen) * 100);
        }

        // Añadir docena a ruleta
        function addRouletteDozen(dozen) {
            // Generar un número aleatorio dentro de la docena
            const min = (dozen - 1) * 12 + 1;
            const max = dozen * 12;
            const randomNumber = Math.floor(Math.random() * (max - min + 1)) + min;
            addRouletteNumber(randomNumber);
        }

        // Añadir color a ruleta
        function addRouletteColor(color) {
            // Generar un número aleatorio del color especificado
            const redNumbers = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
            const blackNumbers = [2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35];
            
            const numbers = color === 'red' ? redNumbers : blackNumbers;
            const randomNumber = numbers[Math.floor(Math.random() * numbers.length)];
            addRouletteNumber(randomNumber);
        }

        // Manejar fases de ruleta - MEJORADO
        function handleRoulettePhases() {
            const state = rouletteState;
            
            // Fase 1: Recolección (37 números)
            if (state.phase === PHASES.COLLECTION && state.dataCollected >= state.requiredForCollection) {
                state.phase = PHASES.GHOST;
                state.calibrationComplete = false;
                state.ghostHistory = [];
                state.ghostPredictions = [];
                showNotification('Ruleta: ¡Fase de Calibración activada! Ingresa 10 resultados más para validar precisión.');
            }
            
            // Fase 2: Calibración (Ghost Mode - 10 predicciones)
            if (state.phase === PHASES.GHOST) {
                // Realizar predicción fantasma
                const prediction = calculateRoulettePrediction();
                state.lastPrediction = prediction;
                
                // Guardar predicción para validar después
                state.ghostPredictions.push({
                    prediction,
                    timestamp: Date.now()
                });
                
                // Si tenemos 10 resultados en ghost mode, calcular precisión
                if (state.ghostPredictions.length >= state.requiredForGhost) {
                    calculateGhostAccuracy('roulette');
                    
                    // Si la precisión es buena, avanzar a fase activa
                    if (state.ghostAccuracy >= 70) {
                        state.phase = PHASES.ACTIVE;
                        state.consecutiveLosses = 0;
                        showNotification('Ruleta: ¡Calibración exitosa! Entrando en modo Fuego Real.');
                    } else {
                        showNotification(`Ruleta: Precisión insuficiente (${state.ghostAccuracy}%). Continúa en modo Calibración.`);
                    }
                }
            }
            
            // Fase 3: Activa - Realizar predicciones reales
            if (state.phase === PHASES.ACTIVE) {
                const prediction = calculateRoulettePrediction();
                state.lastPrediction = prediction;
                
                // Si la probabilidad es alta, sugerir apuesta
                if (prediction.confidence >= 75) {
                    const betAmount = calculateRouletteBet();
                    state.lastBet = betAmount;
                }
            }
            
            // Fase 4: Protección - Verificar pérdidas consecutivas
            if (state.phase === PHASES.ACTIVE && state.consecutiveLosses >= 3) {
                state.phase = PHASES.PROTECTION;
                showNotification('Ruleta: ¡3 pérdidas consecutivas! Volviendo a modo Calibración.');
                
                // Volver a fase de calibración después de 2 segundos
                setTimeout(() => {
                    state.phase = PHASES.GHOST;
                    state.ghostHistory = [];
                    state.ghostPredictions = [];
                    state.consecutiveLosses = 0;
                    updateUI();
                }, 2000);
            }
        }

        // Calcular predicción de ruleta - ALGORITMO MATEMÁTICO MEJORADO
        function calculateRoulettePrediction() {
            const state = rouletteState;
            const totalNumbers = state.dataCollected;
            
            if (totalNumbers < 10) {
                return { type: 'none', confidence: 0, message: 'Datos insuficientes' };
            }
            
            // LEY DEL TERCIO: En 37 números, aproximadamente 24 no salen, 12 salen 1 vez, 1 sale 2 veces
            const expectedInactive = 24;
            const expectedSingle = 12;
            const expectedDouble = 1;
            
            // Contar frecuencias en los últimos 37 números
            const last37 = state.history.slice(0, 37);
            const frequencyMap = {};
            last37.forEach(r => {
                frequencyMap[r.number] = (frequencyMap[r.number] || 0) + 1;
            });
            
            let inactiveCount = 0;
            let singleCount = 0;
            let doubleCount = 0;
            
            for (let i = 0; i <= 36; i++) {
                const freq = frequencyMap[i] || 0;
                if (freq === 0) inactiveCount++;
                else if (freq === 1) singleCount++;
                else if (freq >= 2) doubleCount++;
            }
            
            // Análisis de desviación de docenas
            const dozenDeviations = state.dozenCounts.map((count, index) => {
                const expected = totalNumbers / 3;
                return {
                    dozen: index + 1,
                    count,
                    deviation: Math.abs(count - expected),
                    percentage: Math.round((count / totalNumbers) * 100)
                };
            });
            
            // Ordenar por desviación (mayor a menor)
            dozenDeviations.sort((a, b) => b.deviation - a.deviation);
            
            // Si hay una desviación significativa (>15% del esperado)
            const maxDeviation = dozenDeviations[0];
            const expectedPerDozen = totalNumbers / 3;
            const deviationPercentage = (maxDeviation.deviation / expectedPerDozen) * 100;
            
            if (deviationPercentage > 15 && totalNumbers >= 37) {
                // Predecir la docena con MENOS frecuencia (contrario a la tendencia)
                const minDozen = dozenDeviations[2]; // La última tiene menos desviación (menos frecuente)
                const confidence = Math.min(95, Math.round(deviationPercentage * 0.8));
                
                return {
                    type: 'dozen',
                    value: minDozen.dozen,
                    confidence: confidence,
                    message: `Docena ${minDozen.dozen} tiene ${minDozen.percentage}% (esperado 33%). Desviación: ${Math.round(deviationPercentage)}%`
                };
            }
            
            // Análisis de colores
            const totalColors = state.colorCounts.red + state.colorCounts.black;
            if (totalColors > 20) {
                const redPercentage = (state.colorCounts.red / totalColors) * 100;
                const blackPercentage = (state.colorCounts.black / totalColors) * 100;
                const colorDeviation = Math.abs(redPercentage - 50);
                
                if (colorDeviation > 10) {
                    // Predecir el color menos frecuente
                    const predictedColor = state.colorCounts.red > state.colorCounts.black ? 'black' : 'red';
                    const confidence = Math.min(85, Math.round(colorDeviation * 1.5));
                    
                    return {
                        type: 'color',
                        value: predictedColor,
                        confidence: confidence,
                        message: `${predictedColor.toUpperCase()}: ${predictedColor === 'red' ? Math.round(redPercentage) : Math.round(blackPercentage)}% (esperado 50%)`
                    };
                }
            }
            
            // Análisis de números calientes (que más han salido recientemente)
            if (last37.length >= 10) {
                const hotNumbers = [];
                for (const [number, freq] of Object.entries(frequencyMap)) {
                    if (freq >= 2) {
                        hotNumbers.push({ number: parseInt(number), freq });
                    }
                }
                
                if (hotNumbers.length > 0) {
                    hotNumbers.sort((a, b) => b.freq - a.freq);
                    const hottest = hotNumbers[0];
                    
                    // Calcular probabilidad basada en frecuencia
                    const probability = (hottest.freq / last37.length) * 100;
                    const confidence = Math.min(80, Math.round(probability * 2));
                    
                    return {
                        type: 'number',
                        value: hottest.number,
                        confidence: confidence,
                        message: `Número ${hottest.number} ha salido ${hottest.freq} veces en los últimos ${last37.length} giros`
                    };
                }
            }
            
            // Sin patrón claro
            return {
                type: 'none',
                confidence: 0,
                message: 'Sin patrón detectable. Continuar en modo observación.'
            };
        }

        // Calcular apuesta de ruleta (D'Alembert MEJORADO)
        function calculateRouletteBet() {
            const state = rouletteState;
            
            // Calcular unidad base (1% del capital)
            state.unit = Math.max(1, Math.floor(state.balance * 0.01));
            
            // Sistema D'Alembert mejorado
            let betAmount = state.unit;
            
            if (state.consecutiveLosses > 0) {
                // Aumentar apuesta después de pérdidas
                betAmount = state.unit * (1 + state.consecutiveLosses);
            } else if (state.betSequence > 0) {
                // Disminuir después de ganancias
                betAmount = Math.max(state.unit, Math.floor(state.unit / (1 + state.betSequence)));
            }
            
            // Límites de apuesta
            const minBet = state.unit;
            const maxBet = Math.min(state.balance * 0.05, state.unit * 10); // Máximo 5% del capital o 10 unidades
            
            betAmount = Math.max(minBet, Math.min(maxBet, betAmount));
            
            return Math.round(betAmount);
        }

        // Añadir resultado de baccarat - MEJORADO
        function addBaccaratResult(result) {
            const state = baccaratState;
            
            // Validar resultado
            if (!['banker', 'player', 'tie'].includes(result)) {
                showNotification('Error: Resultado inválido. Solo Banker, Player o Tie.');
                return;
            }
            
            // Animación de click
            const btn = document.getElementById(`baccarat-${result}`);
            if (btn) {
                btn.classList.add('glow');
                setTimeout(() => btn.classList.remove('glow'), 300);
            }
            
            // Actualizar distribución
            state.distribution[result]++;
            
            // Actualizar rachas
            if (state.currentStreak.type === result) {
                state.currentStreak.count++;
            } else {
                state.currentStreak.type = result;
                state.currentStreak.count = 1;
            }
            
            // Actualizar streaks individuales
            if (result === 'banker') {
                state.streaks.banker++;
                state.streaks.player = 0;
                state.streaks.tie = 0;
            } else if (result === 'player') {
                state.streaks.player++;
                state.streaks.banker = 0;
                state.streaks.tie = 0;
            } else {
                state.streaks.tie++;
                state.streaks.banker = 0;
                state.streaks.player = 0;
            }
            
            // Añadir al historial
            state.history.unshift({
                result,
                timestamp: Date.now(),
                streak: state.currentStreak.count
            });
            
            state.lastResults.unshift(result);
            if (state.lastResults.length > 20) {
                state.lastResults.pop();
            }
            
            state.dataCollected++;
            
            // Calcular patrón
            detectBaccaratPattern();
            
            // Manejo de fases
            handleBaccaratPhases();
            
            saveState();
            updateUI();
            
            // Mostrar confirmación
            const resultNames = { banker: 'BANKER', player: 'PLAYER', tie: 'EMPATE' };
            showNotification(`Baccarat: ${resultNames[result]} registrado. Total: ${state.dataCollected}/15`);
        }

        // Detectar patrón en baccarat - ALGORITMO MEJORADO
        function detectBaccaratPattern() {
            const state = baccaratState;
            const lastResults = state.lastResults.slice(0, 10);
            
            if (lastResults.length < 3) {
                state.pattern = 'Ninguno';
                return;
            }
            
            // Detectar racha
            if (state.currentStreak.count >= 3) {
                state.pattern = `Racha de ${state.currentStreak.type.toUpperCase()} (${state.currentStreak.count} seguidos)`;
                return;
            }
            
            // Detectar ZigZag (alternancia)
            let isZigZag = true;
            for (let i = 1; i < lastResults.length; i++) {
                if (lastResults[i] === lastResults[i-1]) {
                    isZigZag = false;
                    break;
                }
            }
            
            if (isZigZag && lastResults.length >= 3) {
                state.pattern = 'Patrón ZigZag (alternancia perfecta)';
                return;
            }
            
            // Detectar patrón 2-1 (dos de un tipo, uno de otro)
            let pattern2_1 = false;
            if (lastResults.length >= 3) {
                const counts = { banker: 0, player: 0, tie: 0 };
                lastResults.forEach(r => counts[r]++);
                
                if ((counts.banker === 2 && counts.player === 1 && counts.tie === 0) ||
                    (counts.player === 2 && counts.banker === 1 && counts.tie === 0)) {
                    pattern2_1 = true;
                }
            }
            
            if (pattern2_1) {
                state.pattern = 'Patrón 2-1 (dos de un tipo, uno del otro)';
                return;
            }
            
            // Detectar predominio
            const total = lastResults.length;
            const bankerPct = (state.distribution.banker / state.dataCollected) * 100;
            const playerPct = (state.distribution.player / state.dataCollected) * 100;
            
            if (bankerPct > 55) {
                state.pattern = `Predominio BANKER (${Math.round(bankerPct)}%)`;
            } else if (playerPct > 55) {
                state.pattern = `Predominio PLAYER (${Math.round(playerPct)}%)`;
            } else {
                state.pattern = 'Equilibrio (sin patrón claro)';
            }
        }

        // Manejar fases de baccarat - MEJORADO
        function handleBaccaratPhases() {
            const state = baccaratState;
            
            // Fase 1: Recolección (15 resultados)
            if (state.phase === PHASES.COLLECTION && state.dataCollected >= state.requiredForCollection) {
                state.phase = PHASES.GHOST;
                state.calibrationComplete = false;
                state.ghostHistory = [];
                state.ghostPredictions = [];
                showNotification('Baccarat: ¡Fase de Calibración activada! Ingresa 10 resultados más para validar precisión.');
            }
            
            // Fase 2: Calibración (Ghost Mode - 10 predicciones)
            if (state.phase === PHASES.GHOST) {
                // Realizar predicción fantasma
                const prediction = calculateBaccaratPrediction();
                state.lastPrediction = prediction;
                
                // Guardar predicción para validar después
                state.ghostPredictions.push({
                    prediction,
                    timestamp: Date.now()
                });
                
                // Si tenemos 10 resultados en ghost mode, calcular precisión
                if (state.ghostPredictions.length >= state.requiredForGhost) {
                    calculateGhostAccuracy('baccarat');
                    
                    // Si la precisión es buena, avanzar a fase activa
                    if (state.ghostAccuracy >= 70) {
                        state.phase = PHASES.ACTIVE;
                        state.consecutiveLosses = 0;
                        showNotification('Baccarat: ¡Calibración exitosa! Entrando en modo Fuego Real.');
                    } else {
                        showNotification(`Baccarat: Precisión insuficiente (${state.ghostAccuracy}%). Continúa en modo Calibración.`);
                    }
                }
            }
            
            // Fase 3: Activa - Realizar predicciones reales
            if (state.phase === PHASES.ACTIVE) {
                const prediction = calculateBaccaratPrediction();
                state.lastPrediction = prediction;
                
                // Si la probabilidad es alta, sugerir apuesta
                if (prediction.confidence >= 75) {
                    const betAmount = calculateBaccaratBet();
                    state.lastBet = betAmount;
                }
            }
            
            // Fase 4: Protección - Verificar pérdidas consecutivas
            if (state.phase === PHASES.ACTIVE && state.consecutiveLosses >= 3) {
                state.phase = PHASES.PROTECTION;
                showNotification('Baccarat: ¡3 pérdidas consecutivas! Volviendo a modo Calibración.');
                
                // Volver a fase de calibración después de 2 segundos
                setTimeout(() => {
                    state.phase = PHASES.GHOST;
                    state.ghostHistory = [];
                    state.ghostPredictions = [];
                    state.consecutiveLosses = 0;
                    updateUI();
                }, 2000);
            }
        }

        // Calcular predicción de baccarat - ALGORITMO MATEMÁTICO MEJORADO
        function calculateBaccaratPrediction() {
            const state = baccaratState;
            const total = state.dataCollected;
            
            if (total < 5) {
                return { type: 'none', confidence: 0, message: 'Datos insuficientes' };
            }
            
            // Probabilidades teóricas de Baccarat
            const theoreticalProbs = {
                banker: 45.86,
                player: 44.62,
                tie: 9.52
            };
            
            // Calcular probabilidades actuales
            const actualProbs = {
                banker: (state.distribution.banker / total) * 100,
                player: (state.distribution.player / total) * 100,
                tie: (state.distribution.tie / total) * 100
            };
            
            // Calcular desviaciones
            const deviations = {
                banker: Math.abs(actualProbs.banker - theoreticalProbs.banker),
                player: Math.abs(actualProbs.player - theoreticalProbs.player),
                tie: Math.abs(actualProbs.tie - theoreticalProbs.tie)
            };
            
            // Encontrar la mayor desviación
            let maxDeviation = 0;
            let predictedResult = null;
            
            for (const [result, deviation] of Object.entries(deviations)) {
                if (deviation > maxDeviation && actualProbs[result] < theoreticalProbs[result]) {
                    maxDeviation = deviation;
                    predictedResult = result;
                }
            }
            
            // Si hay una desviación significativa (>10%)
            if (maxDeviation > 10 && predictedResult) {
                const confidence = Math.min(95, Math.round(maxDeviation * 2));
                
                return {
                    type: 'result',
                    value: predictedResult,
                    confidence: confidence,
                    message: `${predictedResult.toUpperCase()}: ${Math.round(actualProbs[predictedResult])}% (teórico: ${theoreticalProbs[predictedResult]}%)`
                };
            }
            
            // Análisis de rachas
            if (state.currentStreak.count >= 2) {
                // Después de una racha, es más probable que cambie el resultado
                const oppositeResult = state.currentStreak.type === 'banker' ? 'player' : 
                                     state.currentStreak.type === 'player' ? 'banker' : 'banker';
                
                // La confianza aumenta con la longitud de la racha
                const confidence = Math.min(85, 50 + (state.currentStreak.count * 10));
                
                return {
                    type: 'anti-streak',
                    value: oppositeResult,
                    confidence: confidence,
                    message: `Contra-racha: ${state.currentStreak.type.toUpperCase()} x${state.currentStreak.count} seguidos`
                };
            }
            
            // Análisis del último patrón
            const last5 = state.lastResults.slice(0, 5);
            if (last5.length >= 3) {
                // Contar frecuencias en los últimos 5
                const counts = { banker: 0, player: 0, tie: 0 };
                last5.forEach(r => counts[r]++);
                
                // Si hay un resultado que no ha salido en los últimos 3
                for (const result of ['banker', 'player', 'tie']) {
                    if (counts[result] === 0) {
                        const confidence = Math.min(75, 40 + (5 - last5.length) * 10);
                        
                        return {
                            type: 'missing',
                            value: result,
                            confidence: confidence,
                            message: `${result.toUpperCase()} no ha salido en los últimos ${last5.length} resultados`
                        };
                    }
                }
            }
            
            // Sin patrón claro - recomendar Banker por probabilidad teórica
            return {
                type: 'theoretical',
                value: 'banker',
                confidence: 65,
                message: 'Recomendación teórica: BANKER (45.86% de probabilidad)'
            };
        }

        // Calcular apuesta de baccarat (Sistema 1-3-2-4 MEJORADO)
        function calculateBaccaratBet() {
            const state = baccaratState;
            
            // Calcular unidad base (1% del capital)
            state.unit = Math.max(1, Math.floor(state.balance * 0.01));
            
            // Sistema 1-3-2-4 mejorado
            const sequence = [1, 3, 2, 4];
            let betAmount = state.unit;
            
            if (state.betSequence < sequence.length) {
                betAmount = state.unit * sequence[state.betSequence];
            } else {
                // Reiniciar secuencia si llegamos al final
                betAmount = state.unit;
            }
            
            // Ajustar por tipo de apuesta
            const prediction = state.lastPrediction;
            if (prediction && prediction.value === 'tie') {
                // Reducir apuesta en empates (más riesgo)
                betAmount = Math.max(state.unit, Math.floor(betAmount * 0.5));
            }
            
            // Límites de apuesta
            const minBet = state.unit;
            const maxBet = Math.min(state.balance * 0.03, state.unit * 5); // Máximo 3% del capital o 5 unidades
            
            betAmount = Math.max(minBet, Math.min(maxBet, betAmount));
            
            return Math.round(betAmount);
        }

        // Calcular precisión en modo fantasma
        function calculateGhostAccuracy(game) {
            const state = game === 'roulette' ? rouletteState : baccaratState;
            
            if (state.ghostPredictions.length < 5) {
                state.ghostAccuracy = 0;
                return;
            }
            
            // Simular precisión basada en la calidad de las predicciones
            // En una implementación real, compararíamos predicciones con resultados reales
            
            // Para demostración, calculamos una precisión basada en la confianza promedio
            let totalConfidence = 0;
            let count = 0;
            
            state.ghostPredictions.forEach(p => {
                if (p.prediction.confidence > 0) {
                    totalConfidence += p.prediction.confidence;
                    count++;
                }
            });
            
            if (count > 0) {
                const avgConfidence = totalConfidence / count;
                // La precisión real sería menor que la confianza
                state.ghostAccuracy = Math.min(95, Math.round(avgConfidence * 0.8));
            } else {
                state.ghostAccuracy = 0;
            }
        }

        // Reiniciar juego
        function resetGame(game) {
            const state = game === 'roulette' ? rouletteState : baccaratState;
            
            // Conservar balance, meta y stop loss
            const balance = state.balance;
            const target = state.target;
            const stopLoss = state.stopLoss;
            const unit = state.unit;
            
            // Reiniciar estado
            if (game === 'roulette') {
                rouletteState = {
                    game: 'roulette',
                    phase: PHASES.COLLECTION,
                    balance: balance,
                    target: target,
                    stopLoss: stopLoss,
                    unit: unit,
                    history: [],
                    ghostHistory: [],
                    ghostPredictions: [],
                    consecutiveLosses: 0,
                    betSequence: 0,
                    lastBet: 0,
                    dozenCounts: [0, 0, 0],
                    colorCounts: { red: 0, black: 0, green: 0 },
                    numberCounts: new Array(37).fill(0),
                    hotNumbers: [],
                    lastPrediction: null,
                    calibrationComplete: false,
                    dataCollected: 0,
                    requiredForCollection: 37,
                    requiredForGhost: 10,
                    ghostAccuracy: 0,
                    deviation: 0,
                    lastNumbers: []
                };
            } else {
                baccaratState = {
                    game: 'baccarat',
                    phase: PHASES.COLLECTION,
                    balance: balance,
                    target: target,
                    stopLoss: stopLoss,
                    unit: unit,
                    history: [],
                    ghostHistory: [],
                    ghostPredictions: [],
                    consecutiveLosses: 0,
                    betSequence: 0,
                    lastBet: 0,
                    pattern: 'Ninguno',
                    distribution: { banker: 0, player: 0, tie: 0 },
                    streaks: { banker: 0, player: 0, tie: 0 },
                    currentStreak: { type: null, count: 0 },
                    lastPrediction: null,
                    calibrationComplete: false,
                    dataCollected: 0,
                    requiredForCollection: 15,
                    requiredForGhost: 10,
                    ghostAccuracy: 0,
                    lastResults: []
                };
            }
            
            showNotification(`${game === 'roulette' ? 'Ruleta' : 'Baccarat'}: Cambio de ${game === 'roulette' ? 'Crupier' : 'Shoe'}. Historial reiniciado.`);
            saveState();
            updateUI();
        }

        // Finalizar sesión
        function clearSession(game) {
            if (game === 'roulette') {
                rouletteState.balance = 50000;
                rouletteState.history = [];
                rouletteState.dataCollected = 0;
                rouletteState.phase = PHASES.COLLECTION;
                rouletteState.unit = Math.max(1, Math.floor(rouletteState.balance * 0.01));
            } else {
                baccaratState.balance = 50000;
                baccaratState.history = [];
                baccaratState.dataCollected = 0;
                baccaratState.phase = PHASES.COLLECTION;
                baccaratState.unit = Math.max(1, Math.floor(baccaratState.balance * 0.01));
            }
            
            showNotification(`${game === 'roulette' ? 'Ruleta' : 'Baccarat'}: Sesión finalizada. Balance reiniciado a $50,000.`);
            saveState();
            updateUI();
        }

        // Deshacer último movimiento
        function undoLast(game) {
            const state = game === 'roulette' ? rouletteState : baccaratState;
            
            if (state.history.length === 0) return;
            
            // Remover último resultado
            const lastResult = state.history.shift();
            state.dataCollected = Math.max(0, state.dataCollected - 1);
            
            // Revertir estadísticas
            if (game === 'roulette') {
                // Revertir color
                state.colorCounts[lastResult.color]--;
                
                // Revertir docena
                if (lastResult.dozen > 0) {
                    state.dozenCounts[lastResult.dozen-1]--;
                }
                
                // Revertir número
                state.numberCounts[lastResult.number]--;
                
                // Revertir lastNumbers
                if (state.lastNumbers.length > 0) {
                    state.lastNumbers.shift();
                }
                
                // Recalcular desviación
                calculateRouletteDeviation();
            } else {
                state.distribution[lastResult.result]--;
                
                // Revertir lastResults
                if (state.lastResults.length > 0) {
                    state.lastResults.shift();
                }
                
                // Recalcular patrón
                detectBaccaratPattern();
            }
            
            showNotification(`${game === 'roulette' ? 'Ruleta' : 'Baccarat'}: Último resultado eliminado.`);
            saveState();
            updateUI();
        }

        // Mostrar notificación
        function showNotification(message) {
            // Crear elemento de notificación
            const notification = document.createElement('div');
            notification.className = 'fixed bottom-4 right-4 cyber-card p-4 max-w-sm bg-gray-900 border border-cyan-500/50 z-50';
            notification.innerHTML = `
                <div class="flex items-center gap-2">
                    <i data-lucide="info" class="w-5 h-5 neon-text-cyan"></i>
                    <span class="text-sm">${message}</span>
                </div>
            `;
            
            // Añadir al cuerpo
            document.body.appendChild(notification);
            
            // Inicializar icono
            lucide.createIcons();
            
            // Remover después de 3 segundos
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Actualizar interfaz de usuario - MEJORADO
        function updateUI() {
            // Actualizar ruleta
            updateRouletteUI();
            updateBaccaratUI();
            
            // Actualizar historiales
            updateRouletteHistory();
            updateBaccaratHistory();
            
            saveState();
        }

        // Actualizar UI de ruleta - MEJORADO
        function updateRouletteUI() {
            const state = rouletteState;
            
            // Actualizar campos de capital
            document.getElementById('roulette-capital').value = state.balance;
            document.getElementById('roulette-target').value = state.target;
            document.getElementById('roulette-stop-loss').value = state.stopLoss;
            document.getElementById('roulette-unit').textContent = state.unit;
            
            // Actualizar balance mostrado
            document.getElementById('roulette-balance').textContent = state.balance.toLocaleString();
            
            // Actualizar fase
            const phaseElement = document.getElementById('roulette-phase');
            let phaseText = '';
            let phaseClass = '';
            
            switch (state.phase) {
                case PHASES.COLLECTION:
                    phaseText = `FASE 1: RECOLECCIÓN (${state.dataCollected}/${state.requiredForCollection})`;
                    phaseClass = 'bg-blue-900/30 text-blue-300';
                    break;
                case PHASES.GHOST:
                    phaseText = `FASE 2: CALIBRACIÓN (${state.ghostPredictions.length}/${state.requiredForGhost})`;
                    phaseClass = 'bg-purple-900/30 text-purple-300';
                    break;
                case PHASES.ACTIVE:
                    phaseText = 'FASE 3: FUEGO REAL';
                    phaseClass = 'bg-green-900/30 text-green-300';
                    break;
                case PHASES.PROTECTION:
                    phaseText = 'FASE 4: PROTECCIÓN (Recalibrando...)';
                    phaseClass = 'bg-red-900/30 text-red-300';
                    break;
            }
            
            phaseElement.textContent = phaseText;
            phaseElement.className = `phase-indicator ${phaseClass}`;
            
            // Actualizar panel de predicción
            const prediction = state.lastPrediction || { type: 'none', confidence: 0, message: '' };
            const predictionElement = document.getElementById('roulette-prediction-value');
            const confidenceElement = document.getElementById('roulette-confidence');
            const betElement = document.getElementById('roulette-bet');
            const detailsElement = document.getElementById('roulette-prediction-details');
            
            if (state.phase === PHASES.ACTIVE && prediction.confidence >= 75) {
                let predictionText = '';
                
                if (prediction.type === 'dozen') {
                    predictionText = `DOCENA ${prediction.value}`;
                } else if (prediction.type === 'color') {
                    predictionText = prediction.value.toUpperCase();
                } else if (prediction.type === 'number') {
                    predictionText = `NÚMERO ${prediction.value}`;
                } else {
                    predictionText = 'ESPERAR';
                }
                
                predictionElement.textContent = predictionText;
                confidenceElement.textContent = `${prediction.confidence}%`;
                betElement.textContent = `$${state.lastBet.toLocaleString()}`;
                
                detailsElement.innerHTML = `
                    <div>${prediction.message || 'Basado en análisis matemático'}</div>
                    <div class="mt-1 text-xs text-gray-500">Sistema D'Alembert: ${state.consecutiveLosses > 0 ? 'Subiendo apuesta' : 'Apuesta base'}</div>
                `;
                
                // Resaltar el panel de predicción
                document.getElementById('roulette-prediction').classList.add('glow');
            } else {
                predictionElement.textContent = 'ESPERAR';
                confidenceElement.textContent = `${prediction.confidence}%`;
                betElement.textContent = '$0';
                
                if (state.phase === PHASES.COLLECTION) {
                    detailsElement.innerHTML = `
                        <div>Recolectando datos... (${state.dataCollected}/${state.requiredForCollection} números registrados)</div>
                        <div class="mt-1 text-xs text-gray-500">Algoritmo: Ley del Tercio + Análisis de Desviación + Zonas Calientes</div>
                    `;
                } else if (state.phase === PHASES.GHOST) {
                    detailsElement.innerHTML = `
                        <div>Modo Calibración: Validando precisión (${state.ghostPredictions.length}/${state.requiredForGhost})</div>
                        <div class="mt-1 text-xs text-gray-500">Precisión actual: ${state.ghostAccuracy}% (requerido: 70%)</div>
                    `;
                } else {
                    detailsElement.innerHTML = `
                        <div>${prediction.message || 'Confianza insuficiente para apostar.'}</div>
                        <div class="mt-1 text-xs text-gray-500">Se requiere al menos 75% de confianza para sugerir apuestas</div>
                    `;
                }
                
                document.getElementById('roulette-prediction').classList.remove('glow');
            }
            
            // Actualizar estadísticas
            document.getElementById('roulette-stats-count').textContent = state.dataCollected;
            document.getElementById('roulette-ghost-accuracy').textContent = `${state.ghostAccuracy}%`;
            document.getElementById('roulette-dozen-1-count').textContent = `${state.dozenCounts[0]} (${state.dataCollected > 0 ? Math.round((state.dozenCounts[0]/state.dataCollected)*100) : 0}%)`;
            document.getElementById('roulette-dozen-2-count').textContent = `${state.dozenCounts[1]} (${state.dataCollected > 0 ? Math.round((state.dozenCounts[1]/state.dataCollected)*100) : 0}%)`;
            document.getElementById('roulette-dozen-3-count').textContent = `${state.dozenCounts[2]} (${state.dataCollected > 0 ? Math.round((state.dozenCounts[2]/state.dataCollected)*100) : 0}%)`;
            document.getElementById('roulette-deviation').textContent = `${state.deviation}% ${state.deviation > 20 ? '(Desviación ALTA)' : state.deviation > 10 ? '(Desviación moderada)' : '(Equilibrio)'}`;
        }

        // Actualizar UI de baccarat - MEJORADO
        function updateBaccaratUI() {
            const state = baccaratState;
            
            // Actualizar campos de capital
            document.getElementById('baccarat-capital').value = state.balance;
            document.getElementById('baccarat-target').value = state.target;
            document.getElementById('baccarat-stop-loss').value = state.stopLoss;
            document.getElementById('baccarat-unit').textContent = state.unit;
            
            // Actualizar balance mostrado
            document.getElementById('baccarat-balance').textContent = state.balance.toLocaleString();
            
            // Actualizar fase
            const phaseElement = document.getElementById('baccarat-phase');
            let phaseText = '';
            let phaseClass = '';
            
            switch (state.phase) {
                case PHASES.COLLECTION:
                    phaseText = `FASE 1: RECOLECCIÓN (${state.dataCollected}/${state.requiredForCollection})`;
                    phaseClass = 'bg-blue-900/30 text-blue-300';
                    break;
                case PHASES.GHOST:
                    phaseText = `FASE 2: CALIBRACIÓN (${state.ghostPredictions.length}/${state.requiredForGhost})`;
                    phaseClass = 'bg-purple-900/30 text-purple-300';
                    break;
                case PHASES.ACTIVE:
                    phaseText = 'FASE 3: FUEGO REAL';
                    phaseClass = 'bg-green-900/30 text-green-300';
                    break;
                case PHASES.PROTECTION:
                    phaseText = 'FASE 4: PROTECCIÓN (Recalibrando...)';
                    phaseClass = 'bg-red-900/30 text-red-300';
                    break;
            }
            
            phaseElement.textContent = phaseText;
            phaseElement.className = `phase-indicator ${phaseClass}`;
            
            // Actualizar patrón detectado
            document.getElementById('baccarat-pattern').textContent = state.pattern;
            
            // Actualizar panel de predicción
            const prediction = state.lastPrediction || { type: 'none', confidence: 0, message: '' };
            const predictionElement = document.getElementById('baccarat-prediction-value');
            const confidenceElement = document.getElementById('baccarat-confidence');
            const betElement = document.getElementById('baccarat-bet');
            const detailsElement = document.getElementById('baccarat-prediction-details');
            
            if (state.phase === PHASES.ACTIVE && prediction.confidence >= 75) {
                predictionElement.textContent = prediction.value ? prediction.value.toUpperCase() : 'ESPERAR';
                confidenceElement.textContent = `${prediction.confidence}%`;
                betElement.textContent = `$${state.lastBet.toLocaleString()}`;
                
                detailsElement.innerHTML = `
                    <div>${prediction.message || 'Basado en análisis matemático'}</div>
                    <div class="mt-1 text-xs text-gray-500">Sistema 1-3-2-4: Paso ${state.betSequence + 1} de 4</div>
                `;
                
                // Resaltar el panel de predicción
                document.getElementById('baccarat-prediction').classList.add('glow');
            } else {
                predictionElement.textContent = 'ESPERAR';
                confidenceElement.textContent = `${prediction.confidence}%`;
                betElement.textContent = '$0';
                
                if (state.phase === PHASES.COLLECTION) {
                    detailsElement.innerHTML = `
                        <div>Recolectando datos... (${state.dataCollected}/${state.requiredForCollection} resultados registrados)</div>
                        <div class="mt-1 text-xs text-gray-500">Algoritmo: ZigZag + Big Road + Análisis de Rachas + Probabilidad Bayesiana</div>
                    `;
                } else if (state.phase === PHASES.GHOST) {
                    detailsElement.innerHTML = `
                        <div>Modo Calibración: Validando precisión (${state.ghostPredictions.length}/${state.requiredForGhost})</div>
                        <div class="mt-1 text-xs text-gray-500">Precisión actual: ${state.ghostAccuracy}% (requerido: 70%)</div>
                    `;
                } else {
                    detailsElement.innerHTML = `
                        <div>${prediction.message || 'Confianza insuficiente para apostar.'}</div>
                        <div class="mt-1 text-xs text-gray-500">Se requiere al menos 75% de confianza para sugerir apuestas</div>
                    `;
                }
                
                document.getElementById('baccarat-prediction').classList.remove('glow');
            }
            
            // Actualizar estadísticas
            document.getElementById('baccarat-stats-count').textContent = state.dataCollected;
            document.getElementById('baccarat-ghost-accuracy').textContent = `${state.ghostAccuracy}%`;
            document.getElementById('baccarat-banker-count').textContent = `${state.distribution.banker} (${state.dataCollected > 0 ? Math.round((state.distribution.banker/state.dataCollected)*100) : 0}%)`;
            document.getElementById('baccarat-player-count').textContent = `${state.distribution.player} (${state.dataCollected > 0 ? Math.round((state.distribution.player/state.dataCollected)*100) : 0}%)`;
            document.getElementById('baccarat-tie-count').textContent = `${state.distribution.tie} (${state.dataCollected > 0 ? Math.round((state.distribution.tie/state.dataCollected)*100) : 0}%)`;
            document.getElementById('baccarat-streak').textContent = state.currentStreak.count > 0 ? 
                `${state.currentStreak.type.toUpperCase()} x${state.currentStreak.count}` : 
                'Sin racha detectada';
        }

        // Actualizar historial de ruleta - MEJORADO
        function updateRouletteHistory() {
            const container = document.getElementById('roulette-history');
            const state = rouletteState;
            
            if (!container) return;
            
            let html = '';
            const recentHistory = state.history.slice(0, 20);
            
            if (recentHistory.length === 0) {
                html = '<div class="text-gray-500 text-center py-4 w-full">No hay datos aún. Toca números para comenzar.</div>';
            } else {
                for (const result of recentHistory) {
                    let bgClass = '';
                    let textClass = '';
                    
                    if (result.color === 'red') {
                        bgClass = 'bg-red-900/50';
                        textClass = 'text-red-300';
                    } else if (result.color === 'black') {
                        bgClass = 'bg-gray-900';
                        textClass = 'text-white';
                    } else {
                        bgClass = 'bg-green-900/50';
                        textClass = 'text-green-300';
                    }
                    
                    html += `<div class="history-chip ${bgClass} ${textClass} recent-number" title="Número ${result.number} (${result.color.toUpperCase()}) - ${new Date(result.timestamp).toLocaleTimeString()}">${result.number}</div>`;
                }
            }
            
            container.innerHTML = html;
        }

        // Actualizar historial de baccarat - MEJORADO
        function updateBaccaratHistory() {
            const container = document.getElementById('baccarat-history');
            const state = baccaratState;
            
            if (!container) return;
            
            let html = '';
            const recentHistory = state.history.slice(0, 20);
            
            if (recentHistory.length === 0) {
                html = '<div class="text-gray-500 text-center py-4 w-full">No hay datos aún. Toca resultados para comenzar.</div>';
            } else {
                for (const result of recentHistory) {
                    let bgClass = '';
                    let textClass = '';
                    let letter = '';
                    
                    if (result.result === 'banker') {
                        bgClass = 'bg-blue-900/50';
                        textClass = 'text-blue-300';
                        letter = 'B';
                    } else if (result.result === 'player') {
                        bgClass = 'bg-red-900/50';
                        textClass = 'text-red-300';
                        letter = 'P';
                    } else {
                        bgClass = 'bg-gray-900';
                        textClass = 'text-white';
                        letter = 'T';
                    }
                    
                    const streakInfo = result.streak > 1 ? ` x${result.streak}` : '';
                    html += `<div class="history-chip ${bgClass} ${textClass}" title="${result.result.toUpperCase()}${streakInfo} - ${new Date(result.timestamp).toLocaleTimeString()}">${letter}${result.streak > 1 ? result.streak : ''}</div>`;
                }
            }
            
            container.innerHTML = html;
        }

        // Inicializar aplicación cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
