<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ROULETTE MASTER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --neon-cyan: #0ff0fc;
            --neon-green: #00ff9d;
            --dark-bg: #0a0a0f;
            --darker-bg: #050508;
            --card-bg: #11111a;
        }
        
        body {
            background-color: var(--dark-bg);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow-x: hidden;
        }
        
        .neon-cyan {
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .neon-green {
            color: var(--neon-green);
            text-shadow: 0 0 10px rgba(0, 255, 157, 0.5);
        }
        
        .neon-border {
            border: 2px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 240, 252, 0.3);
        }
        
        .neon-glow {
            box-shadow: 0 0 20px rgba(0, 240, 252, 0.5);
        }
        
        .chip-shadow {
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7));
        }
        
        .phase-1 { border-left: 5px solid #ff6b6b; }
        .phase-2 { border-left: 5px solid #ffd93d; }
        .phase-3 { border-left: 5px solid #6bcf7f; }
        .phase-4 { border-left: 5px solid #ff8e6b; }
        
        .red-roulette { background-color: #d32f2f; }
        .black-roulette { background-color: #212121; }
        .green-roulette { background-color: #2e7d32; }
        
        .red-roulette:hover { background-color: #f44336; }
        .black-roulette:hover { background-color: #424242; }
        .green-roulette:hover { background-color: #4caf50; }
        
        .history-item {
            transition: all 0.3s ease;
        }
        
        .history-item:hover {
            transform: scale(1.05);
        }
        
        .progress-bar {
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            background-color: #333;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-cyan), var(--neon-green));
            transition: width 0.5s ease;
        }
        
        .phase-badge {
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .chip {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: black;
            margin: 3px;
            transition: transform 0.2s;
        }
        
        .chip:hover {
            transform: scale(1.1);
        }
        
        .chip-500 { background-color: #ff9800; }
        .chip-2500 { background-color: #2196f3; }
        .chip-5000 { background-color: #4caf50; }
        .chip-25000 { background-color: #9c27b0; }
        .chip-100000 { background-color: #f44336; }
        .chip-500000 { background-color: #ffeb3b; color: #333; }
        .chip-1200000 { background-color: #00bcd4; }
        .chip-5000000 { background-color: #795548; }
        
        @media (max-width: 640px) {
            .chip {
                width: 40px;
                height: 40px;
                font-size: 12px;
            }
        }
        
        /* Animaciones */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 240, 252, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 240, 252, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 240, 252, 0); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        
        .stat-card {
            background: linear-gradient(135deg, rgba(16, 16, 26, 0.9), rgba(10, 10, 15, 0.9));
            border: 1px solid rgba(0, 240, 252, 0.2);
            border-radius: 12px;
        }
        
        .prediction-high {
            background: linear-gradient(135deg, rgba(0, 255, 157, 0.1), rgba(0, 240, 252, 0.1));
            border: 2px solid var(--neon-green);
        }
        
        .prediction-low {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(255, 142, 107, 0.1));
            border: 2px solid #ff6b6b;
        }
    </style>
</head>
<body class="min-h-screen p-4">
    <div class="max-w-6xl mx-auto">
        <!-- Encabezado -->
        <header class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold neon-cyan mb-2">NEON ROULETTE MASTER</h1>
            <p class="text-lg text-gray-300 mb-4">Sistema de predicción matemática para ruleta europea</p>
            
            <div class="flex flex-wrap justify-center gap-4 mb-6">
                <div class="stat-card p-3 min-w-[180px]">
                    <div class="text-sm text-gray-400">Fase Actual</div>
                    <div id="currentPhase" class="text-xl font-bold neon-green">Fase 1: Recolección</div>
                </div>
                
                <div class="stat-card p-3 min-w-[180px]">
                    <div class="text-sm text-gray-400">Saldo</div>
                    <div id="currentBalance" class="text-xl font-bold">$10,000</div>
                </div>
                
                <div class="stat-card p-3 min-w-[180px]">
                    <div class="text-sm text-gray-400">Precisión</div>
                    <div id="accuracy" class="text-xl font-bold">0%</div>
                </div>
            </div>
        </header>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Panel izquierdo: Control y Fichas -->
            <div class="lg:col-span-1 space-y-6">
                <!-- Panel de Control -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-cyan mb-4 flex items-center">
                        <i class="fas fa-sliders-h mr-2"></i> Panel de Control
                    </h2>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-gray-300 mb-2">Capital Inicial ($)</label>
                            <input type="number" id="initialCapital" value="10000" min="100" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        </div>
                        
                        <div>
                            <label class="block text-gray-300 mb-2">Meta de Ganancia ($)</label>
                            <input type="number" id="profitTarget" value="15000" min="100" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        </div>
                        
                        <div>
                            <label class="block text-gray-300 mb-2">Stop Loss ($)</label>
                            <input type="number" id="stopLoss" value="5000" min="100" class="w-full p-3 rounded-lg bg-gray-800 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        </div>
                        
                        <div>
                            <label class="block text-gray-300 mb-2">Progreso hacia la Meta</label>
                            <div class="progress-bar mt-2">
                                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                            </div>
                            <div class="flex justify-between text-sm text-gray-400 mt-1">
                                <span id="currentProgress">$10,000</span>
                                <span id="targetProgress">$15,000</span>
                            </div>
                        </div>
                        
                        <button id="updateSettings" class="w-full bg-gradient-to-r from-cyan-600 to-green-600 hover:from-cyan-700 hover:to-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 transform hover:scale-105">
                            <i class="fas fa-sync-alt mr-2"></i> Actualizar Configuración
                        </button>
                    </div>
                </div>
                
                <!-- Fichas Inteligentes -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-green mb-4 flex items-center">
                        <i class="fas fa-coins mr-2"></i> Fichas Inteligentes
                    </h2>
                    
                    <div class="mb-4">
                        <div class="text-gray-300 mb-2">Apuesta Calculada:</div>
                        <div id="currentBet" class="text-3xl font-bold neon-cyan text-center">$0</div>
                    </div>
                    
                    <div class="text-gray-300 mb-3">Composición de fichas:</div>
                    <div id="chipComposition" class="flex flex-wrap justify-center gap-2 mb-6">
                        <!-- Las fichas se generarán dinámicamente -->
                        <div class="text-gray-500 text-center py-4">Ingresa números para calcular la apuesta</div>
                    </div>
                    
                    <div class="text-gray-300 mb-3">Valores de fichas disponibles:</div>
                    <div class="flex flex-wrap justify-center gap-2">
                        <div class="chip chip-500">500</div>
                        <div class="chip chip-2500">2.5K</div>
                        <div class="chip chip-5000">5K</div>
                        <div class="chip chip-25000">25K</div>
                        <div class="chip chip-100000">100K</div>
                        <div class="chip chip-500000">500K</div>
                        <div class="chip chip-1200000">1.2M</div>
                        <div class="chip chip-5000000">5M</div>
                    </div>
                </div>
                
                <!-- Controles -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-cyan mb-4 flex items-center">
                        <i class="fas fa-cogs mr-2"></i> Controles
                    </h2>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <button id="changeDealer" class="bg-gray-800 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 flex flex-col items-center justify-center">
                            <i class="fas fa-user-secret text-2xl mb-2"></i>
                            <span>Cambiar Crupier</span>
                        </button>
                        
                        <button id="undoLast" class="bg-gray-800 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 flex flex-col items-center justify-center">
                            <i class="fas fa-undo text-2xl mb-2"></i>
                            <span>Deshacer</span>
                        </button>
                        
                        <button id="exportData" class="col-span-2 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 flex items-center justify-center">
                            <i class="fas fa-file-export mr-2"></i>
                            <span>Exportar Datos (JSON)</span>
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Panel central: Teclado y Predicciones -->
            <div class="lg:col-span-2 space-y-6">
                <!-- Predicción Actual -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-green mb-4 flex items-center">
                        <i class="fas fa-brain mr-2"></i> Predicción del Sistema
                    </h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="bg-gray-800 rounded-lg p-4">
                            <div class="text-gray-400 mb-2">Docena Predicha:</div>
                            <div id="predictedDozen" class="text-4xl font-bold neon-cyan text-center py-4">-</div>
                            <div class="text-gray-400 text-sm text-center">(Basado en análisis de tendencias)</div>
                        </div>
                        
                        <div class="bg-gray-800 rounded-lg p-4">
                            <div class="text-gray-400 mb-2">Confianza:</div>
                            <div id="confidenceLevel" class="text-4xl font-bold text-center py-4">-</div>
                            <div class="text-gray-400 text-sm text-center">Nivel de certeza del algoritmo</div>
                        </div>
                    </div>
                    
                    <div class="mt-4 bg-gray-800 rounded-lg p-4">
                        <div class="text-gray-400 mb-2">Números Recomendados:</div>
                        <div id="recommendedNumbers" class="text-xl font-bold text-center py-2 text-green-400">Esperando datos...</div>
                        <div class="text-gray-400 text-sm text-center">Mejores opciones según el algoritmo</div>
                    </div>
                    
                    <div class="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div class="bg-gray-800 rounded-lg p-4">
                            <div class="text-gray-400 mb-1">Docena Caliente</div>
                            <div id="hotDozen" class="text-2xl font-bold text-yellow-400">-</div>
                            <div class="text-gray-500 text-xs">Más frecuente</div>
                        </div>
                        
                        <div class="bg-gray-800 rounded-lg p-4">
                            <div class="text-gray-400 mb-1">Docena Fría</div>
                            <div id="coldDozen" class="text-2xl font-bold text-blue-400">-</div>
                            <div class="text-gray-500 text-xs">Menos frecuente</div>
                        </div>
                        
                        <div class="bg-gray-800 rounded-lg p-4">
                            <div class="text-gray-400 mb-1">Último Acierto</div>
                            <div id="lastHit" class="text-2xl font-bold text-green-400">-</div>
                            <div class="text-gray-500 text-xs">Hace X tiros</div>
                        </div>
                    </div>
                    
                    <div class="mt-6 p-4 rounded-lg" id="phaseMessage">
                        <div class="flex items-center">
                            <i class="fas fa-info-circle text-cyan-400 mr-3 text-xl"></i>
                            <div>
                                <div class="font-bold neon-cyan">Fase 1: Recolección de Datos</div>
                                <div class="text-gray-300">Por favor, ingresa los primeros 37 números para calibrar el sistema.</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Teclado Numérico -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-cyan mb-4 flex items-center">
                        <i class="fas fa-keyboard mr-2"></i> Teclado de Ruleta
                    </h2>
                    
                    <div class="mb-6 text-center">
                        <div class="text-gray-300 mb-2">Números ingresados: <span id="numbersEnteredCount">0</span>/37 (Fase 1)</div>
                        <div class="progress-bar mx-auto max-w-md">
                            <div id="numbersProgress" class="progress-fill" style="width: 0%"></div>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-4 sm:grid-cols-7 md:grid-cols-8 lg:grid-cols-9 gap-3">
                        <!-- Los botones del 0 al 36 se generarán dinámicamente -->
                    </div>
                    
                    <div class="mt-6 flex justify-center gap-4">
                        <button id="clearAll" class="bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300">
                            <i class="fas fa-trash-alt mr-2"></i> Limpiar Todo
                        </button>
                        
                        <button id="simulateRandom" class="bg-blue-800 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300">
                            <i class="fas fa-dice mr-2"></i> Simular Aleatorio
                        </button>
                    </div>
                </div>
                
                <!-- Historial -->
                <div class="stat-card p-5 neon-border fade-in">
                    <h2 class="text-2xl font-bold neon-green mb-4 flex items-center">
                        <i class="fas fa-history mr-2"></i> Historial de Tiradas
                    </h2>
                    
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead>
                                <tr class="text-gray-400 border-b border-gray-800">
                                    <th class="py-2 text-left">#</th>
                                    <th class="py-2 text-left">Número</th>
                                    <th class="py-2 text-left">Color</th>
                                    <th class="py-2 text-left">Docena</th>
                                    <th class="py-2 text-left">Predicción</th>
                                    <th class="py-2 text-left">Resultado</th>
                                    <th class="py-2 text-left">Apuesta</th>
                                    <th class="py-2 text-left">Saldo</th>
                                </tr>
                            </thead>
                            <tbody id="historyBody">
                                <!-- Las filas se generarán dinámicamente -->
                                <tr>
                                    <td colspan="8" class="text-center py-8 text-gray-500">No hay historial aún. Ingresa números para comenzar.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="mt-4 flex justify-between text-sm text-gray-400">
                        <div>Total tiradas: <span id="totalSpins">0</span></div>
                        <div>Aciertos: <span id="totalHits">0</span> (<span id="hitPercentage">0</span>%)</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Footer -->
        <footer class="mt-10 text-center text-gray-500 text-sm border-t border-gray-800 pt-6">
            <p class="neon-cyan font-bold">NEON ROULETTE MASTER V1 - Sistema de Predicción Matemática</p>
            <p class="mt-2">Algoritmo basado en la Ley del Tercio y gestión D'Alembert • Solo para fines educativos</p>
            <p class="mt-2">© 2023 - Todos los derechos reservados</p>
        </footer>
    </div>

    <script>
        // ============================================
        // CEREBRO MATEMÁTICO V2.0 - MOTOR DE PROBABILIDAD
        // ============================================
        const NEON_BRAIN = {
            // Configuración de la estrategia
            config: {
                windowSize: 37, // Analizar últimos 37 tiros (ciclo completo de ruleta)
                minConfidence: 75, // Solo apostar si la confianza > 75%
                baseUnit: 100, // Apuesta base inicial
            },

            // Estado interno del cerebro
            brainState: {
                currentBetLevel: 1, // Para D'Alembert
                lastOutcome: null, // 'WIN' o 'LOSS'
                cycleHistory: [], // Historial del ciclo actual
                accuracyHistory: [], // Historial de precisión
            },

            /**
             * ANALIZAR EL CILINDRO Y GENERAR PREDICCIÓN
             * @param {Array} history - Array de números [12, 5, 0, ...]
             * @returns {Object} Predicción con docena, confianza y razón
             */
            analyze: function(history) {
                // Necesitamos al menos 10 números para empezar a analizar
                if (history.length < 10) {
                    return {
                        dozen: null,
                        confidence: 0,
                        reason: "Recopilando datos (" + history.length + "/10)...",
                        numbers: [],
                        hotDozen: null,
                        coldDozen: null
                    };
                }

                // 1. Cortar el historial a la ventana de análisis (últimos 37 tiros)
                const recentHistory = history.slice(0, this.config.windowSize);
                
                // 2. Contar frecuencias de Docenas (1-3) e identificar el cero
                let dozenCounts = { 1: 0, 2: 0, 3: 0 };
                let zeroCount = 0;
                let lastAppearance = { 1: 999, 2: 999, 3: 999 }; // Turnos sin salir

                recentHistory.forEach((num, index) => {
                    if (num === 0) {
                        zeroCount++;
                        return;
                    }
                    
                    let dozen = Math.ceil(num / 12);
                    if (dozen >= 1 && dozen <= 3) {
                        dozenCounts[dozen]++;
                        
                        // Registrar cuándo fue la última vez que salió (menor índice = más reciente)
                        if (lastAppearance[dozen] === 999) lastAppearance[dozen] = index;
                    }
                });

                // 3. Calcular estadísticas de desviación
                const totalNonZero = recentHistory.length - zeroCount;
                const expectedPerDozen = totalNonZero / 3; // Ley del Tercio
                
                // 4. Calcular Puntaje de Probabilidad (Score)
                // Fórmula: Ponderación por déficit + retraso + desviación estándar
                let scores = { 1: 0, 2: 0, 3: 0 };
                let deviationFactors = { 1: 0, 2: 0, 3: 0 };

                for (let d = 1; d <= 3; d++) {
                    // Factor A: Déficit de Frecuencia (Si salió poco, suma puntos)
                    let deficit = expectedPerDozen - dozenCounts[d];
                    scores[d] += (deficit * 15); 

                    // Factor B: Retraso (Si hace mucho no sale, suma puntos exponencialmente)
                    if (lastAppearance[d] > 5) {
                        let delayBonus = Math.min(50, lastAppearance[d] * 3);
                        scores[d] += delayBonus;
                    }
                    
                    // Factor C: Penalización por salida reciente (evitar repetición inmediata)
                    if (lastAppearance[d] === 0) scores[d] -= 25;
                    
                    // Factor D: Desviación estándar ponderada
                    deviationFactors[d] = Math.abs(dozenCounts[d] - expectedPerDozen) / expectedPerDozen;
                    scores[d] += (deviationFactors[d] * 30);
                }

                // 5. Determinar Ganador (docena con mayor puntaje)
                let bestDozen = 1;
                let bestScore = scores[1];
                
                for (let d = 2; d <= 3; d++) {
                    if (scores[d] > bestScore) {
                        bestScore = scores[d];
                        bestDozen = d;
                    }
                }

                // 6. Calcular Confianza (0-100%)
                // Normalizamos el score basándonos en una escala logarítmica
                let confidence = 0;
                if (bestScore > 0) {
                    // Fórmula: 40% base + 60% según puntaje normalizado
                    let normalizedScore = Math.min(100, bestScore / 2);
                    confidence = 40 + (normalizedScore * 0.6);
                }
                
                // Ajustar confianza según desviación
                confidence = Math.min(95, Math.max(20, confidence));

                // 7. Determinar docena caliente y fría
                let hotDozen = 1;
                let maxCount = dozenCounts[1];
                let coldDozen = 1;
                let minCount = dozenCounts[1];
                
                for (let d = 2; d <= 3; d++) {
                    if (dozenCounts[d] > maxCount) {
                        maxCount = dozenCounts[d];
                        hotDozen = d;
                    }
                    if (dozenCounts[d] < minCount) {
                        minCount = dozenCounts[d];
                        coldDozen = d;
                    }
                }

                // 8. Generar números recomendados para la docena predicha
                let recommendedNumbers = this.getHotNumbersInDozen(recentHistory, bestDozen);

                return {
                    dozen: parseInt(bestDozen),
                    confidence: Math.round(confidence),
                    reason: `Déficit: ${dozenCounts[bestDozen]} vs Esperado: ${Math.round(expectedPerDozen)} | Retraso: ${lastAppearance[bestDozen]} giros`,
                    numbers: recommendedNumbers,
                    hotDozen: hotDozen,
                    coldDozen: coldDozen,
                    stats: {
                        counts: dozenCounts,
                        lastAppearance: lastAppearance,
                        expected: expectedPerDozen,
                        scores: scores
                    }
                };
            },

            /**
             * GESTIÓN DE CAPITAL (D'ALEMBERT MEJORADO)
             * @param {Boolean} won - Si ganó el último tiro
             * @param {Number} currentBalance - Saldo actual
             * @param {Number} baseBet - Apuesta base
             * @returns {Number} Próxima apuesta calculada
             */
            calculateNextBet: function(won, currentBalance, baseBet = null) {
                const base = baseBet || this.config.baseUnit;
                
                if (won) {
                    // Si gana, bajamos 1 nivel (mínimo 1)
                    this.brainState.currentBetLevel = Math.max(1, this.brainState.currentBetLevel - 1);
                    this.brainState.lastOutcome = 'WIN';
                    
                    // Registrar acierto
                    this.brainState.accuracyHistory.push(1);
                } else {
                    // Si pierde, subimos 1 nivel
                    this.brainState.currentBetLevel++;
                    this.brainState.lastOutcome = 'LOSS';
                    
                    // Registrar fallo
                    this.brainState.accuracyHistory.push(0);
                }
                
                // Limitar historial de precisión a los últimos 50
                if (this.brainState.accuracyHistory.length > 50) {
                    this.brainState.accuracyHistory.shift();
                }
                
                // Calcular apuesta: nivel * base * factor de seguridad
                let calculatedBet = this.brainState.currentBetLevel * base;
                
                // Factor de seguridad: nunca apostar más del 5% del saldo
                const maxBet = currentBalance * 0.05;
                if (calculatedBet > maxBet) {
                    calculatedBet = Math.max(base, maxBet);
                }
                
                // Asegurar apuesta mínima
                calculatedBet = Math.max(base, calculatedBet);
                
                return Math.round(calculatedBet);
            },

            /**
             * Calcular precisión actual del sistema
             * @returns {Number} Precisión en porcentaje
             */
            calculateAccuracy: function() {
                if (this.brainState.accuracyHistory.length === 0) return 0;
                
                const hits = this.brainState.accuracyHistory.filter(v => v === 1).length;
                return Math.round((hits / this.brainState.accuracyHistory.length) * 100);
            },

            /**
             * Reiniciar progresión D'Alembert
             */
            resetProgression: function() {
                this.brainState.currentBetLevel = 1;
                this.brainState.lastOutcome = null;
            },

            /**
             * Helper: Busca qué números de una docena específica están saliendo más
             */
            getHotNumbersInDozen: function(history, dozen) {
                let numberCounts = {};
                
                // Contar frecuencia de cada número en la docena
                history.forEach(n => {
                    if (n !== 0 && Math.ceil(n/12) === dozen) {
                        numberCounts[n] = (numberCounts[n] || 0) + 1;
                    }
                });
                
                // Ordenar por frecuencia y devolver los top 4
                let sortedNumbers = Object.keys(numberCounts)
                    .sort((a,b) => numberCounts[b] - numberCounts[a])
                    .slice(0, 4)
                    .map(Number);
                
                // Si no hay suficientes datos, devolver números aleatorios de la docena
                if (sortedNumbers.length < 3) {
                    let start = (dozen - 1) * 12 + 1;
                    let allNumbers = [];
                    for(let i = 0; i < 12; i++) allNumbers.push(start + i);
                    
                    // Mezclar y tomar 4
                    allNumbers = allNumbers.sort(() => Math.random() - 0.5);
                    return allNumbers.slice(0, 4);
                }
                
                return sortedNumbers;
            },

            /**
             * Verificar si el sistema está listo para fase activa
             * @param {Number} minSpins - Mínimo de tiros de prueba
             * @param {Number} requiredAccuracy - Precisión requerida
             * @returns {Boolean} True si está listo
             */
            isReadyForActivePhase: function(minSpins = 10, requiredAccuracy = 75) {
                if (this.brainState.accuracyHistory.length < minSpins) return false;
                
                const accuracy = this.calculateAccuracy();
                return accuracy >= requiredAccuracy;
            }
        };

        // ============================================
        // ESTADO DE LA APLICACIÓN
        // ============================================
        const state = {
            phase: 1, // 1: Recolección, 2: Calibración, 3: Fuego Real, 4: Protección
            balance: 10000,
            initialBalance: 10000,
            profitTarget: 15000,
            stopLoss: 5000,
            currentBet: 0,
            numbers: [],
            history: [],
            predictions: [],
            consecutiveLosses: 0,
            unitSize: 0,
            currentPrediction: null,
            lastPredictionResult: null
        };

        // Valores de fichas disponibles
        const chipValues = [500, 2500, 5000, 25000, 100000, 500000, 1200000, 5000000];

        // Colores de la ruleta (0 es verde, otros según reglas europeas)
        const rouletteColors = {
            0: 'green',
            32: 'red', 19: 'red', 21: 'red', 25: 'red', 34: 'red', 27: 'red', 36: 'red', 30: 'red', 23: 'red', 5: 'red', 16: 'red', 1: 'red', 14: 'red', 9: 'red', 18: 'red', 7: 'red', 12: 'red', 3: 'red',
            15: 'black', 4: 'black', 2: 'black', 17: 'black', 6: 'black', 13: 'black', 11: 'black', 8: 'black', 10: 'black', 24: 'black', 33: 'black', 20: 'black', 31: 'black', 22: 'black', 29: 'black', 28: 'black', 35: 'black', 26: 'black'
        };

        // Mapeo de números a docenas
        const numberToDozen = (number) => {
            if (number === 0) return 0; // El cero no pertenece a ninguna docena
            return Math.ceil(number / 12);
        };

        // ============================================
        // INICIALIZACIÓN
        // ============================================
        document.addEventListener('DOMContentLoaded', function() {
            loadState();
            initializeKeyboard();
            updateUI();
            setupEventListeners();
        });

        // Cargar estado desde localStorage
        function loadState() {
            const savedState = localStorage.getItem('neonRouletteState');
            if (savedState) {
                const parsed = JSON.parse(savedState);
                Object.assign(state, parsed);
                console.log('Estado cargado desde localStorage');
            }
        }

        // Guardar estado en localStorage
        function saveState() {
            localStorage.setItem('neonRouletteState', JSON.stringify(state));
        }

        // Inicializar teclado numérico
        function initializeKeyboard() {
            const keyboard = document.querySelector('.grid.gap-3');
            keyboard.innerHTML = '';
            
            // Botón para el 0 (verde)
            createNumberButton(0, keyboard);
            
            // Botones para los números 1-36
            for (let i = 1; i <= 36; i++) {
                createNumberButton(i, keyboard);
            }
        }

        // Crear botón para número
        function createNumberButton(number, container) {
            const button = document.createElement('button');
            button.className = `py-4 rounded-lg font-bold text-xl transition duration-300 transform hover:scale-105 ${getNumberColorClass(number)}`;
            button.textContent = number;
            button.dataset.number = number;
            
            button.addEventListener('click', () => {
                addNumber(number);
            });
            
            container.appendChild(button);
        }

        // Obtener clase CSS para el color del número
        function getNumberColorClass(number) {
            const color = rouletteColors[number] || 'black';
            return `${color}-roulette`;
        }

        // Configurar event listeners
        function setupEventListeners() {
            // Actualizar configuración
            document.getElementById('updateSettings').addEventListener('click', updateSettings);
            
            // Cambiar crupier
            document.getElementById('changeDealer').addEventListener('click', changeDealer);
            
            // Deshacer última jugada
            document.getElementById('undoLast').addEventListener('click', undoLast);
            
            // Exportar datos
            document.getElementById('exportData').addEventListener('click', exportData);
            
            // Limpiar todo
            document.getElementById('clearAll').addEventListener('click', clearAll);
            
            // Simular aleatorio
            document.getElementById('simulateRandom').addEventListener('click', simulateRandom);
        }

        // ============================================
        // LÓGICA DE NEGOCIO CON CEREBRO MATEMÁTICO
        // ============================================

        // Añadir número al historial
        function addNumber(number) {
            // Registrar número
            state.numbers.unshift(number); // Añadir al inicio para historial reciente primero
            
            // Obtener predicción del cerebro matemático
            const prediction = NEON_BRAIN.analyze(state.numbers);
            state.currentPrediction = prediction;
            
            let hit = false;
            let betAmount = 0;
            let resultMessage = "";
            
            // Determinar docena del número
            const actualDozen = numberToDozen(number);
            
            if (state.phase === 1) {
                // Fase 1: Solo recolección
                resultMessage = `Número ${number} registrado. ${state.numbers.length}/37 para calibración.`;
                
                if (state.numbers.length >= 37) {
                    state.phase = 2;
                    resultMessage = "¡Datos iniciales completados! Pasando a FASE 2: CALIBRACIÓN.";
                }
            } 
            else if (state.phase === 2) {
                // Fase 2: Calibración (Ghost Mode)
                if (prediction.dozen && prediction.confidence > 0) {
                    // Verificar si acertó
                    hit = (prediction.dozen === actualDozen && actualDozen !== 0);
                    
                    // Registrar resultado en el cerebro
                    NEON_BRAIN.brainState.accuracyHistory.push(hit ? 1 : 0);
                    
                    // Verificar si pasa a fase 3
                    if (NEON_BRAIN.isReadyForActivePhase(10, 75)) {
                        state.phase = 3;
                        NEON_BRAIN.resetProgression();
                        resultMessage = `¡Calibración exitosa! Precisión: ${NEON_BRAIN.calculateAccuracy()}%. Pasando a FASE 3: FUEGO REAL.`;
                    } else {
                        resultMessage = `Calibrando... Precisión: ${NEON_BRAIN.calculateAccuracy()}% (${NEON_BRAIN.brainState.accuracyHistory.filter(v => v === 1).length}/${NEON_BRAIN.brainState.accuracyHistory.length} aciertos)`;
                    }
                } else {
                    resultMessage = "Analizando patrones...";
                }
            } 
            else if (state.phase === 3 || state.phase === 4) {
                // Fase 3 y 4: Modo activo con apuestas reales
                if (prediction.dozen && prediction.confidence >= NEON_BRAIN.config.minConfidence) {
                    // Calcular apuesta usando D'Alembert
                    const lastWon = state.lastPredictionResult === 'WIN';
                    betAmount = NEON_BRAIN.calculateNextBet(lastWon, state.balance, state.balance * 0.01);
                    state.currentBet = betAmount;
                    
                    // Verificar si acertó
                    hit = (prediction.dozen === actualDozen && actualDozen !== 0);
                    
                    // Actualizar saldo
                    if (hit) {
                        // Ganar: apostar a una docena paga 2:1
                        const winAmount = betAmount * 2;
                        state.balance += winAmount;
                        state.consecutiveLosses = 0;
                        state.lastPredictionResult = 'WIN';
                        resultMessage = `¡ACIERTO! +$${winAmount.toLocaleString()}`;
                    } else {
                        // Perder
                        state.balance -= betAmount;
                        state.consecutiveLosses++;
                        state.lastPredictionResult = 'LOSS';
                        resultMessage = `Fallo. -$${betAmount.toLocaleString()}`;
                        
                        // El cero no afecta la progresión D'Alembert
                        if (number === 0) {
                            resultMessage = `Cero (0). Pérdida congelada. -$${betAmount.toLocaleString()}`;
                        }
                        
                        // Verificar si pasa a fase de protección
                        if (state.consecutiveLosses >= 3) {
                            state.phase = 4;
                            resultMessage += " ¡3 pérdidas consecutivas! Activando FASE 4: PROTECCIÓN.";
                        }
                    }
                    
                    // Verificar stop loss y profit target
                    if (state.balance <= state.stopLoss) {
                        resultMessage = "¡STOP LOSS ALCANZADO! Reiniciando sistema.";
                        resetToPhase1();
                    } else if (state.balance >= state.profitTarget) {
                        resultMessage = "¡META DE GANANCIA ALCANZADA! ¡FELICIDADES!";
                    }
                    
                    // Si está en fase 4 y acertó, volver a fase 3
                    if (state.phase === 4 && hit) {
                        state.phase = 3;
                        state.consecutiveLosses = 0;
                        resultMessage += " ¡Acierto en protección! Volviendo a FASE 3.";
                    }
                } else {
                    // Confianza insuficiente, no apostar
                    betAmount = 0;
                    resultMessage = `Confianza insuficiente (${prediction.confidence}%). Esperando mejor oportunidad.`;
                }
            }
            
            // Registrar en historial
            const historyEntry = {
                number,
                color: rouletteColors[number],
                dozen: actualDozen,
                prediction: prediction.dozen,
                confidence: prediction.confidence,
                hit,
                bet: betAmount,
                balance: state.balance,
                phase: state.phase,
                result: resultMessage,
                timestamp: new Date().toLocaleTimeString()
            };
            
            state.history.unshift(historyEntry);
            
            // Guardar estado y actualizar UI
            saveState();
            updateUI();
            updatePhaseMessage(resultMessage);
            
            // Efecto visual en el botón del número
            const button = document.querySelector(`button[data-number="${number}"]`);
            if (button) {
                button.classList.add('neon-glow');
                setTimeout(() => button.classList.remove('neon-glow'), 1000);
            }
        }

        // ============================================
        // ACTUALIZACIÓN DE UI
        // ============================================
        function updateUI() {
            // Actualizar contadores
            document.getElementById('numbersEnteredCount').textContent = state.numbers.length;
            document.getElementById('totalSpins').textContent = state.history.length;
            
            // Actualizar barra de progreso de números
            const numbersProgress = Math.min(100, (state.numbers.length / 37) * 100);
            document.getElementById('numbersProgress').style.width = numbersProgress + '%';
            
            // Actualizar saldo y precisión
            document.getElementById('currentBalance').textContent = '$' + state.balance.toLocaleString();
            
            // Calcular precisión del cerebro
            const accuracy = NEON_BRAIN.calculateAccuracy();
            document.getElementById('accuracy').textContent = accuracy + '%';
            
            // Actualizar fase
            updatePhaseDisplay();
            
            // Actualizar progreso hacia la meta
            updateProgressBar();
            
            // Actualizar predicciones
            updatePredictions();
            
            // Actualizar apuesta y fichas
            updateBetDisplay();
            
            // Actualizar historial
            updateHistory();
            
            // Actualizar estadísticas de docenas
            updateDozenStatsDisplay();
        }

        // Actualizar visualización de fase
        function updatePhaseDisplay() {
            const phaseNames = {
                1: 'Fase 1: Recolección',
                2: 'Fase 2: Calibración',
                3: 'Fase 3: Fuego Real',
                4: 'Fase 4: Protección'
            };
            
            const phaseElement = document.getElementById('currentPhase');
            phaseElement.textContent = phaseNames[state.phase];
            
            // Color según fase
            if (state.phase === 1) phaseElement.className = "text-xl font-bold text-red-400";
            else if (state.phase === 2) phaseElement.className = "text-xl font-bold text-yellow-400";
            else if (state.phase === 3) phaseElement.className = "text-xl font-bold text-green-400";
            else phaseElement.className = "text-xl font-bold text-orange-400";
        }

        // Actualizar mensaje de fase en UI
        function updatePhaseMessage(message) {
            const phaseMessageElement = document.getElementById('phaseMessage');
            
            // Determinar clase según fase y tipo de mensaje
            let messageClass = "p-4 rounded-lg border ";
            if (message.includes("ACIERTO") || message.includes("META")) {
                messageClass += "prediction-high";
            } else if (message.includes("Fallo") || message.includes("Pérdida")) {
                messageClass += "prediction-low";
            } else if (state.phase === 1) {
                messageClass += "bg-blue-900/30 border-blue-700";
            } else if (state.phase === 2) {
                messageClass += "bg-yellow-900/30 border-yellow-700";
            } else if (state.phase === 3) {
                messageClass += "bg-green-900/30 border-green-700";
            } else {
                messageClass += "bg-red-900/30 border-red-700";
            }
            
            phaseMessageElement.className = `${messageClass} mt-6 fade-in`;
            phaseMessageElement.innerHTML = `
                <div class="flex items-center">
                    <i class="fas fa-info-circle ${state.phase === 3 ? 'text-green-400' : state.phase === 4 ? 'text-red-400' : 'text-cyan-400'} mr-3 text-xl"></i>
                    <div>
                        <div class="font-bold ${state.phase === 3 ? 'text-green-400' : state.phase === 4 ? 'text-red-400' : 'text-cyan-400'}">${document.getElementById('currentPhase').textContent}</div>
                        <div class="text-gray-300">${message}</div>
                    </div>
                </div>
            `;
        }

        // Actualizar barra de progreso hacia la meta
        function updateProgressBar() {
            const progressFill = document.getElementById('progressFill');
            const currentProgress = document.getElementById('currentProgress');
            const targetProgress = document.getElementById('targetProgress');
            
            const start = state.initialBalance;
            const target = state.profitTarget;
            const current = state.balance;
            
            // Calcular progreso normalizado (0% a 100%)
            let progressPercent = 0;
            if (target > start) {
                progressPercent = ((current - start) / (target - start)) * 100;
            }
            
            // Limitar entre 0% y 100%
            progressPercent = Math.max(0, Math.min(100, progressPercent));
            
            progressFill.style.width = progressPercent + '%';
            currentProgress.textContent = '$' + current.toLocaleString();
            targetProgress.textContent = '$' + target.toLocaleString();
        }

        // Actualizar predicciones en UI
        function updatePredictions() {
            // Actualizar docena predicha
            const predictedDozenElement = document.getElementById('predictedDozen');
            const confidenceElement = document.getElementById('confidenceLevel');
            
            if (state.currentPrediction && state.currentPrediction.dozen) {
                predictedDozenElement.textContent = `Docena ${state.currentPrediction.dozen}`;
                confidenceElement.textContent = `${state.currentPrediction.confidence}%`;
                
                // Color según confianza
                if (state.currentPrediction.confidence >= 75) {
                    predictedDozenElement.className = "text-4xl font-bold text-green-400 text-center py-4 pulse";
                    confidenceElement.className = "text-4xl font-bold text-green-400 text-center py-4";
                } else if (state.currentPrediction.confidence >= 50) {
                    predictedDozenElement.className = "text-4xl font-bold text-yellow-400 text-center py-4";
                    confidenceElement.className = "text-4xl font-bold text-yellow-400 text-center py-4";
                } else {
                    predictedDozenElement.className = "text-4xl font-bold text-gray-400 text-center py-4";
                    confidenceElement.className = "text-4xl font-bold text-gray-400 text-center py-4";
                }
            } else {
                predictedDozenElement.textContent = "-";
                predictedDozenElement.className = "text-4xl font-bold text-gray-500 text-center py-4";
                confidenceElement.textContent = "-";
                confidenceElement.className = "text-4xl font-bold text-gray-500 text-center py-4";
            }
            
            // Actualizar números recomendados
            const recommendedNumbersElement = document.getElementById('recommendedNumbers');
            if (state.currentPrediction && state.currentPrediction.numbers && state.currentPrediction.numbers.length > 0) {
                recommendedNumbersElement.textContent = state.currentPrediction.numbers.join(', ');
                recommendedNumbersElement.className = "text-xl font-bold text-center py-2 text-green-400";
            } else {
                recommendedNumbersElement.textContent = "Esperando datos...";
                recommendedNumbersElement.className = "text-xl font-bold text-center py-2 text-gray-500";
            }
        }

        // Actualizar estadísticas de docenas en UI
        function updateDozenStatsDisplay() {
            if (state.currentPrediction) {
                document.getElementById('hotDozen').textContent = state.currentPrediction.hotDozen ? 
                    `Docena ${state.currentPrediction.hotDozen}` : "-";
                document.getElementById('coldDozen').textContent = state.currentPrediction.coldDozen ? 
                    `Docena ${state.currentPrediction.coldDozen}` : "-";
            }
            
            // Último acierto
            const lastHitElement = document.getElementById('lastHit');
            if (state.history.length > 0) {
                const lastHit = state.history.find(entry => entry.hit);
                if (lastHit) {
                    lastHitElement.textContent = `#${lastHit.number}`;
                } else {
                    lastHitElement.textContent = "Ninguno";
                }
            } else {
                lastHitElement.textContent = "-";
            }
        }

        // Actualizar visualización de apuesta y fichas
        function updateBetDisplay() {
            // Actualizar monto de apuesta
            const currentBetElement = document.getElementById('currentBet');
            if (state.phase >= 3 && state.currentBet > 0) {
                currentBetElement.textContent = '$' + state.currentBet.toLocaleString();
                currentBetElement.className = "text-3xl font-bold neon-cyan text-center";
            } else {
                currentBetElement.textContent = 'Modo Prueba';
                currentBetElement.className = "text-3xl font-bold text-gray-500 text-center";
            }
            
            // Actualizar composición de fichas
            updateChipComposition();
        }

        // Actualizar composición de fichas
        function updateChipComposition() {
            const chipCompositionElement = document.getElementById('chipComposition');
            
            if (state.phase < 3 || state.currentBet <= 0) {
                chipCompositionElement.innerHTML = '<div class="text-gray-500 text-center py-4">Ingresa números para calcular la apuesta</div>';
                return;
            }
            
            // Calcular qué fichas usar para la apuesta actual
            let remaining = state.currentBet;
            const chipsUsed = [];
            
            // Ordenar fichas de mayor a menor valor
            const sortedChips = [...chipValues].sort((a, b) => b - a);
            
            for (const chipValue of sortedChips) {
                if (remaining >= chipValue) {
                    const count = Math.floor(remaining / chipValue);
                    for (let i = 0; i < count; i++) {
                        chipsUsed.push(chipValue);
                    }
                    remaining %= chipValue;
                }
            }
            
            // Si queda un resto, añadir una ficha más pequeña
            if (remaining > 0) {
                for (const chipValue of sortedChips.slice().reverse()) {
                    if (chipValue >= remaining) {
                        chipsUsed.push(chipValue);
                        break;
                    }
                }
            }
            
            // Generar HTML para las fichas
            if (chipsUsed.length === 0) {
                chipCompositionElement.innerHTML = '<div class="text-gray-500 text-center py-4">Apuesta demasiado pequeña para fichas disponibles</div>';
            } else {
                chipCompositionElement.innerHTML = '';
                chipsUsed.forEach(chipValue => {
                    const chipElement = document.createElement('div');
                    chipElement.className = `chip chip-${chipValue} chip-shadow`;
                    chipElement.textContent = chipValue >= 1000000 ? 
                        (chipValue / 1000000) + 'M' : 
                        chipValue >= 1000 ? 
                        (chipValue / 1000) + 'K' : 
                        chipValue;
                    chipElement.title = `$${chipValue.toLocaleString()}`;
                    chipCompositionElement.appendChild(chipElement);
                });
            }
        }

        // Actualizar historial en UI
        function updateHistory() {
            const historyBody = document.getElementById('historyBody');
            const totalHitsElement = document.getElementById('totalHits');
            const hitPercentageElement = document.getElementById('hitPercentage');
            
            if (state.history.length === 0) {
                historyBody.innerHTML = '<tr><td colspan="8" class="text-center py-8 text-gray-500">No hay historial aún. Ingresa números para comenzar.</td></tr>';
                totalHitsElement.textContent = '0';
                hitPercentageElement.textContent = '0';
                return;
            }
            
            // Calcular estadísticas
            const totalHits = state.history.filter(entry => entry.hit).length;
            const hitPercentage = state.history.length > 0 ? ((totalHits / state.history.length) * 100).toFixed(1) : '0';
            
            totalHitsElement.textContent = totalHits;
            hitPercentageElement.textContent = hitPercentage;
            
            // Generar filas de historial (mostrar las últimas 20)
            const recentHistory = state.history.slice(0, 20);
            historyBody.innerHTML = '';
            
            recentHistory.forEach((entry, index) => {
                const row = document.createElement('tr');
                row.className = `history-item border-b border-gray-800 hover:bg-gray-800/50 ${index % 2 === 0 ? 'bg-gray-900/30' : ''}`;
                
                row.innerHTML = `
                    <td class="py-3">${state.history.length - index}</td>
                    <td class="py-3">
                        <span class="inline-block w-8 h-8 rounded-full text-center leading-8 font-bold ${entry.color}-roulette">
                            ${entry.number}
                        </span>
                    </td>
                    <td class="py-3">
                        <span class="capitalize">${entry.color}</span>
                    </td>
                    <td class="py-3">${entry.dozen > 0 ? 'Docena ' + entry.dozen : 'Cero'}</td>
                    <td class="py-3">${entry.prediction ? 'Docena ' + entry.prediction : '-'}</td>
                    <td class="py-3">
                        <span class="${entry.hit ? 'text-green-400' : 'text-red-400'} font-bold">
                            ${entry.hit ? '✓ ACIERTO' : '✗ FALLO'}
                        </span>
                    </td>
                    <td class="py-3">${entry.bet ? '$' + entry.bet.toLocaleString() : '-'}</td>
                    <td class="py-3 ${entry.balance >= state.initialBalance ? 'text-green-400' : 'text-red-400'}">
                        $${entry.balance.toLocaleString()}
                    </td>
                `;
                
                historyBody.appendChild(row);
            });
        }

        // ============================================
        // FUNCIONES DE CONTROL
        // ============================================

        // Actualizar configuración
        function updateSettings() {
            const initialCapital = parseInt(document.getElementById('initialCapital').value) || 10000;
            const profitTarget = parseInt(document.getElementById('profitTarget').value) || 15000;
            const stopLoss = parseInt(document.getElementById('stopLoss').value) || 5000;
            
            // Validar valores
            if (initialCapital < 100) {
                alert('El capital inicial debe ser al menos $100');
                return;
            }
            
            if (profitTarget <= initialCapital) {
                alert('La meta de ganancia debe ser mayor al capital inicial');
                return;
            }
            
            if (stopLoss >= initialCapital) {
                alert('El stop loss debe ser menor al capital inicial');
                return;
            }
            
            // Actualizar estado
            state.initialBalance = initialCapital;
            state.balance = initialCapital;
            state.profitTarget = profitTarget;
            state.stopLoss = stopLoss;
            
            // Reiniciar sistema si estaba en fase activa
            if (state.phase >= 3) {
                state.phase = 1;
                state.numbers = [];
                state.history = [];
                state.consecutiveLosses = 0;
                state.currentBet = 0;
                NEON_BRAIN.resetProgression();
                NEON_BRAIN.brainState.accuracyHistory = [];
                updatePhaseMessage("Configuración actualizada. Reiniciando a FASE 1: RECOLECCIÓN.");
            }
            
            // Guardar y actualizar
            saveState();
            updateUI();
            
            // Mostrar confirmación
            alert('Configuración actualizada correctamente');
        }

        // Cambiar crupier (reiniciar sistema)
        function changeDealer() {
            if (confirm('¿Cambiar de crupier? Esto reiniciará el historial y volverá a la Fase 1, pero mantendrá el saldo actual.')) {
                // Mantener saldo pero reiniciar todo lo demás
                const currentBalance = state.balance;
                
                // Reiniciar estado (excepto saldo)
                Object.assign(state, {
                    phase: 1,
                    currentBet: 0,
                    numbers: [],
                    history: [],
                    predictions: [],
                    consecutiveLosses: 0,
                    currentPrediction: null,
                    lastPredictionResult: null,
                    balance: currentBalance
                });
                
                // Reiniciar cerebro matemático
                NEON_BRAIN.resetProgression();
                NEON_BRAIN.brainState.accuracyHistory = [];
                NEON_BRAIN.brainState.cycleHistory = [];
                
                saveState();
                updateUI();
                updatePhaseMessage("¡Crupier cambiado! Sistema reiniciado. Comienza a ingresar números para la nueva sesión.");
            }
        }

        // Deshacer última jugada
        function undoLast() {
            if (state.numbers.length === 0) {
                alert('No hay números para deshacer');
                return;
            }
            
            // Eliminar último número
            const lastNumber = state.numbers.shift();
            
            // Eliminar última entrada del historial si existe
            if (state.history.length > 0) {
                const lastEntry = state.history.shift();
                
                // Revertir cambios en saldo si estaba en fase activa
                if (state.phase >= 3 && lastEntry.bet) {
                    if (lastEntry.hit) {
                        // Revertir ganancia
                        state.balance -= lastEntry.bet * 2;
                        state.consecutiveLosses = Math.max(0, state.consecutiveLosses - 1);
                    } else {
                        // Revertir pérdida
                        state.balance += lastEntry.bet;
                        state.consecutiveLosses = Math.max(0, state.consecutiveLosses - 1);
                    }
                    
                    // Revertir progresión D'Alembert
                    if (lastEntry.hit) {
                        NEON_BRAIN.brainState.currentBetLevel = Math.min(10, NEON_BRAIN.brainState.currentBetLevel + 1);
                    } else {
                        NEON_BRAIN.brainState.currentBetLevel = Math.max(1, NEON_BRAIN.brainState.currentBetLevel - 1);
                    }
                }
                
                // Eliminar del historial de precisión del cerebro
                if (state.phase >= 2 && NEON_BRAIN.brainState.accuracyHistory.length > 0) {
                    NEON_BRAIN.brainState.accuracyHistory.pop();
                }
            }
            
            // Si después de deshacer tenemos menos de 37 números y estábamos en fase > 1, volver a fase 1
            if (state.numbers.length < 37 && state.phase > 1) {
                state.phase = 1;
            }
            
            // Recalcular predicción actual
            state.currentPrediction = NEON_BRAIN.analyze(state.numbers);
            
            saveState();
            updateUI();
            updatePhaseMessage("Último número deshecho. Números restantes: " + state.numbers.length);
        }

        // Exportar datos como JSON
        function exportData() {
            const exportObj = {
                metadata: {
                    app: "NEON ROULETTE MASTER V2",
                    exportDate: new Date().toISOString(),
                    phase: state.phase,
                    balance: state.balance,
                    initialBalance: state.initialBalance,
                    profitTarget: state.profitTarget,
                    stopLoss: state.stopLoss,
                    brainAccuracy: NEON_BRAIN.calculateAccuracy()
                },
                statistics: {
                    totalSpins: state.numbers.length,
                    testAccuracy: NEON_BRAIN.calculateAccuracy(),
                    currentBetLevel: NEON_BRAIN.brainState.currentBetLevel,
                    recentHistory: state.history.slice(0, 50)
                },
                brainAnalysis: state.currentPrediction,
                rawData: {
                    numbers: state.numbers,
                    fullHistory: state.history
                }
            };
            
            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `neon-roulette-data-${new Date().toISOString().slice(0,10)}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            updatePhaseMessage("Datos exportados correctamente como " + exportFileDefaultName);
        }

        // Limpiar todo (reinicio completo)
        function clearAll() {
            if (confirm('¿Reiniciar completamente el sistema? Esto borrará todos los datos y restablecerá el saldo inicial.')) {
                // Restablecer estado completamente
                Object.assign(state, {
                    phase: 1,
                    balance: parseInt(document.getElementById('initialCapital').value) || 10000,
                    initialBalance: parseInt(document.getElementById('initialCapital').value) || 10000,
                    profitTarget: parseInt(document.getElementById('profitTarget').value) || 15000,
                    stopLoss: parseInt(document.getElementById('stopLoss').value) || 5000,
                    currentBet: 0,
                    numbers: [],
                    history: [],
                    predictions: [],
                    consecutiveLosses: 0,
                    currentPrediction: null,
                    lastPredictionResult: null
                });
                
                // Reiniciar cerebro matemático
                NEON_BRAIN.resetProgression();
                NEON_BRAIN.brainState.accuracyHistory = [];
                NEON_BRAIN.brainState.cycleHistory = [];
                
                saveState();
                updateUI();
                updatePhaseMessage("Sistema reiniciado completamente. Comienza a ingresar números.");
            }
        }

        // Simular número aleatorio
        function simulateRandom() {
            const randomNumber = Math.floor(Math.random() * 37); // 0-36
            addNumber(randomNumber);
        }

        // Reiniciar a fase 1
        function resetToPhase1() {
            state.phase = 1;
            state.numbers = [];
            state.history = [];
            state.consecutiveLosses = 0;
            state.currentBet = 0;
            state.balance = state.initialBalance;
            
            NEON_BRAIN.resetProgression();
            NEON_BRAIN.brainState.accuracyHistory = [];
            
            saveState();
            updateUI();
        }

        // ============================================
        // INICIALIZACIÓN FINAL
        // ============================================
        // Asegurar que la UI esté actualizada
        window.addEventListener('beforeunload', saveState);
    </script>
</body>
</html>
